<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="IELE Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../assets/img/favicon.ico" />

<title>IELE Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/iele-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../Design">Design</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1>babel-types</h1>
<blockquote>
<p>This module contains methods for building ASTs manually and for checking the types of AST nodes.</p>
</blockquote>
<h2>Install</h2>
<pre class="hljs"><code>npm install --save-dev babel-types
</code></pre>
<h2>API</h2>
<!-- begin generated section -->
<h3>anyTypeAnnotation</h3>
<pre class="hljs"><code>t.anyTypeAnnotation()
</code></pre>
<p>See also <code>t.isAnyTypeAnnotation(node, opts)</code> and <code>t.assertAnyTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>arrayExpression</h3>
<pre class="hljs"><code>t.arrayExpression(elements)
</code></pre>
<p>See also <code>t.isArrayExpression(node, opts)</code> and <code>t.assertArrayExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>elements</code>: <code>Array&lt;null | Expression | SpreadElement&gt;</code> (default: <code>[]</code>)</li>
</ul>
<hr>
<h3>arrayPattern</h3>
<pre class="hljs"><code>t.arrayPattern(elements, typeAnnotation)
</code></pre>
<p>See also <code>t.isArrayPattern(node, opts)</code> and <code>t.assertArrayPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>elements</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>arrayTypeAnnotation</h3>
<pre class="hljs"><code>t.arrayTypeAnnotation(elementType)
</code></pre>
<p>See also <code>t.isArrayTypeAnnotation(node, opts)</code> and <code>t.assertArrayTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>elementType</code> (required)</li>
</ul>
<hr>
<h3>arrowFunctionExpression</h3>
<pre class="hljs"><code>t.arrowFunctionExpression(params, body, <span class="hljs-keyword">async</span>)
</code></pre>
<p>See also <code>t.isArrowFunctionExpression(node, opts)</code> and <code>t.assertArrowFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Expression</code> (required)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>assignmentExpression</h3>
<pre class="hljs"><code>t.assignmentExpression(operator, left, right)
</code></pre>
<p>See also <code>t.isAssignmentExpression(node, opts)</code> and <code>t.assertAssignmentExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>string</code> (required)</li>
<li><code>left</code>: <code>LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>assignmentPattern</h3>
<pre class="hljs"><code>t.assignmentPattern(left, right)
</code></pre>
<p>See also <code>t.isAssignmentPattern(node, opts)</code> and <code>t.assertAssignmentPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>left</code>: <code>Identifier</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>awaitExpression</h3>
<pre class="hljs"><code>t.awaitExpression(argument)
</code></pre>
<p>See also <code>t.isAwaitExpression(node, opts)</code> and <code>t.assertAwaitExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>binaryExpression</h3>
<pre class="hljs"><code>t.binaryExpression(operator, left, right)
</code></pre>
<p>See also <code>t.isBinaryExpression(node, opts)</code> and <code>t.assertBinaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>&apos;+&apos; | &apos;-&apos; | &apos;/&apos; | &apos;%&apos; | &apos;*&apos; | &apos;**&apos; | &apos;&amp;&apos; | &apos;|&apos; | &apos;&gt;&gt;&apos; | &apos;&gt;&gt;&gt;&apos; | &apos;&lt;&lt;&apos; | &apos;^&apos; | &apos;==&apos; | &apos;===&apos; | &apos;!=&apos; | &apos;!==&apos; | &apos;in&apos; | &apos;instanceof&apos; | &apos;&gt;&apos; | &apos;&lt;&apos; | &apos;&gt;=&apos; | &apos;&lt;=&apos;</code> (required)</li>
<li><code>left</code>: <code>Expression</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>bindExpression</h3>
<pre class="hljs"><code>t.bindExpression(object, callee)
</code></pre>
<p>See also <code>t.isBindExpression(node, opts)</code> and <code>t.assertBindExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>object</code> (required)</li>
<li><code>callee</code> (required)</li>
</ul>
<hr>
<h3>blockStatement</h3>
<pre class="hljs"><code>t.blockStatement(body, directives)
</code></pre>
<p>See also <code>t.isBlockStatement(node, opts)</code> and <code>t.assertBlockStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>Statement</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li>
</ul>
<hr>
<h3>booleanLiteral</h3>
<pre class="hljs"><code>t.booleanLiteral(value)
</code></pre>
<p>See also <code>t.isBooleanLiteral(node, opts)</code> and <code>t.assertBooleanLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>boolean</code> (required)</li>
</ul>
<hr>
<h3>booleanLiteralTypeAnnotation</h3>
<pre class="hljs"><code>t.booleanLiteralTypeAnnotation()
</code></pre>
<p>See also <code>t.isBooleanLiteralTypeAnnotation(node, opts)</code> and <code>t.assertBooleanLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr>
<h3>booleanTypeAnnotation</h3>
<pre class="hljs"><code>t.booleanTypeAnnotation()
</code></pre>
<p>See also <code>t.isBooleanTypeAnnotation(node, opts)</code> and <code>t.assertBooleanTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>breakStatement</h3>
<pre class="hljs"><code>t.breakStatement(label)
</code></pre>
<p>See also <code>t.isBreakStatement(node, opts)</code> and <code>t.assertBreakStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>callExpression</h3>
<pre class="hljs"><code>t.callExpression(callee, <span class="hljs-built_in">arguments</span>)
</code></pre>
<p>See also <code>t.isCallExpression(node, opts)</code> and <code>t.assertCallExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>Array&lt;Expression | SpreadElement&gt;</code> (required)</li>
</ul>
<hr>
<h3>catchClause</h3>
<pre class="hljs"><code>t.catchClause(param, body)
</code></pre>
<p>See also <code>t.isCatchClause(node, opts)</code> and <code>t.assertCatchClause(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code></p>
<ul>
<li><code>param</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<hr>
<h3>classBody</h3>
<pre class="hljs"><code>t.classBody(body)
</code></pre>
<p>See also <code>t.isClassBody(node, opts)</code> and <code>t.assertClassBody(node, opts)</code>.</p>
<ul>
<li><code>body</code>: <code>Array&lt;ClassMethod | ClassProperty&gt;</code> (required)</li>
</ul>
<hr>
<h3>classDeclaration</h3>
<pre class="hljs"><code>t.classDeclaration(id, superClass, body, decorators)
</code></pre>
<p>See also <code>t.isClassDeclaration(node, opts)</code> and <code>t.assertClassDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Statement</code>, <code>Declaration</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
<li><code>implements</code> (default: <code>null</code>)</li>
<li><code>mixins</code> (default: <code>null</code>)</li>
<li><code>superTypeParameters</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>classExpression</h3>
<pre class="hljs"><code>t.classExpression(id, superClass, body, decorators)
</code></pre>
<p>See also <code>t.isClassExpression(node, opts)</code> and <code>t.assertClassExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
<li><code>implements</code> (default: <code>null</code>)</li>
<li><code>mixins</code> (default: <code>null</code>)</li>
<li><code>superTypeParameters</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>classImplements</h3>
<pre class="hljs"><code>t.classImplements(id, typeParameters)
</code></pre>
<p>See also <code>t.isClassImplements(node, opts)</code> and <code>t.assertClassImplements(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<hr>
<h3>classMethod</h3>
<pre class="hljs"><code>t.classMethod(kind, key, params, body, computed, <span class="hljs-keyword">static</span>)
</code></pre>
<p>See also <code>t.isClassMethod(node, opts)</code> and <code>t.assertClassMethod(node, opts)</code>.</p>
<p>Aliases: <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code></p>
<ul>
<li><code>kind</code>: <code>&quot;get&quot; | &quot;set&quot; | &quot;method&quot; | &quot;constructor&quot;</code> (default: <code>&apos;method&apos;</code>)</li>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>static</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>decorators</code> (default: <code>null</code>)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>classProperty</h3>
<pre class="hljs"><code>t.classProperty(key, value, typeAnnotation, decorators, computed)
</code></pre>
<p>See also <code>t.isClassProperty(node, opts)</code> and <code>t.assertClassProperty(node, opts)</code>.</p>
<p>Aliases: <code>Property</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<h3>conditionalExpression</h3>
<pre class="hljs"><code>t.conditionalExpression(test, consequent, alternate)
</code></pre>
<p>See also <code>t.isConditionalExpression(node, opts)</code> and <code>t.assertConditionalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Expression</code> (required)</li>
<li><code>alternate</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>continueStatement</h3>
<pre class="hljs"><code>t.continueStatement(label)
</code></pre>
<p>See also <code>t.isContinueStatement(node, opts)</code> and <code>t.assertContinueStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>debuggerStatement</h3>
<pre class="hljs"><code>t.debuggerStatement()
</code></pre>
<p>See also <code>t.isDebuggerStatement(node, opts)</code> and <code>t.assertDebuggerStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<hr>
<h3>declareClass</h3>
<pre class="hljs"><code>t.declareClass(id, typeParameters, <span class="hljs-keyword">extends</span>, body)
</code></pre>
<p>See also <code>t.isDeclareClass(node, opts)</code> and <code>t.assertDeclareClass(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<hr>
<h3>declareExportDeclaration</h3>
<pre class="hljs"><code>t.declareExportDeclaration(declaration, specifiers, source)
</code></pre>
<p>See also <code>t.isDeclareExportDeclaration(node, opts)</code> and <code>t.assertDeclareExportDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>declaration</code> (required)</li>
<li><code>specifiers</code> (required)</li>
<li><code>source</code> (required)</li>
</ul>
<hr>
<h3>declareFunction</h3>
<pre class="hljs"><code>t.declareFunction(id)
</code></pre>
<p>See also <code>t.isDeclareFunction(node, opts)</code> and <code>t.assertDeclareFunction(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
</ul>
<hr>
<h3>declareInterface</h3>
<pre class="hljs"><code>t.declareInterface(id, typeParameters, <span class="hljs-keyword">extends</span>, body)
</code></pre>
<p>See also <code>t.isDeclareInterface(node, opts)</code> and <code>t.assertDeclareInterface(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<hr>
<h3>declareModule</h3>
<pre class="hljs"><code>t.declareModule(id, body)
</code></pre>
<p>See also <code>t.isDeclareModule(node, opts)</code> and <code>t.assertDeclareModule(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<hr>
<h3>declareModuleExports</h3>
<pre class="hljs"><code>t.declareModuleExports(typeAnnotation)
</code></pre>
<p>See also <code>t.isDeclareModuleExports(node, opts)</code> and <code>t.assertDeclareModuleExports(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<hr>
<h3>declareOpaqueType</h3>
<pre class="hljs"><code>t.declareOpaqueType(id, typeParameters, supertype)
</code></pre>
<p>See also <code>t.isDeclareOpaqueType(node, opts)</code> and <code>t.assertDeclareOpaqueType(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>supertype</code> (required)</li>
</ul>
<hr>
<h3>declareTypeAlias</h3>
<pre class="hljs"><code>t.declareTypeAlias(id, typeParameters, right)
</code></pre>
<p>See also <code>t.isDeclareTypeAlias(node, opts)</code> and <code>t.assertDeclareTypeAlias(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>right</code> (required)</li>
</ul>
<hr>
<h3>declareVariable</h3>
<pre class="hljs"><code>t.declareVariable(id)
</code></pre>
<p>See also <code>t.isDeclareVariable(node, opts)</code> and <code>t.assertDeclareVariable(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
</ul>
<hr>
<h3>decorator</h3>
<pre class="hljs"><code>t.decorator(expression)
</code></pre>
<p>See also <code>t.isDecorator(node, opts)</code> and <code>t.assertDecorator(node, opts)</code>.</p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>directive</h3>
<pre class="hljs"><code>t.directive(value)
</code></pre>
<p>See also <code>t.isDirective(node, opts)</code> and <code>t.assertDirective(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>DirectiveLiteral</code> (required)</li>
</ul>
<hr>
<h3>directiveLiteral</h3>
<pre class="hljs"><code>t.directiveLiteral(value)
</code></pre>
<p>See also <code>t.isDirectiveLiteral(node, opts)</code> and <code>t.assertDirectiveLiteral(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<hr>
<h3>doExpression</h3>
<pre class="hljs"><code>t.doExpression(body)
</code></pre>
<p>See also <code>t.isDoExpression(node, opts)</code> and <code>t.assertDoExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
</ul>
<hr>
<h3>doWhileStatement</h3>
<pre class="hljs"><code>t.doWhileStatement(test, body)
</code></pre>
<p>See also <code>t.isDoWhileStatement(node, opts)</code> and <code>t.assertDoWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>emptyStatement</h3>
<pre class="hljs"><code>t.emptyStatement()
</code></pre>
<p>See also <code>t.isEmptyStatement(node, opts)</code> and <code>t.assertEmptyStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<hr>
<h3>emptyTypeAnnotation</h3>
<pre class="hljs"><code>t.emptyTypeAnnotation()
</code></pre>
<p>See also <code>t.isEmptyTypeAnnotation(node, opts)</code> and <code>t.assertEmptyTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>existentialTypeParam</h3>
<pre class="hljs"><code>t.existentialTypeParam()
</code></pre>
<p>See also <code>t.isExistentialTypeParam(node, opts)</code> and <code>t.assertExistentialTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr>
<h3>exportAllDeclaration</h3>
<pre class="hljs"><code>t.exportAllDeclaration(source)
</code></pre>
<p>See also <code>t.isExportAllDeclaration(node, opts)</code> and <code>t.assertExportAllDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>source</code>: <code>StringLiteral</code> (required)</li>
</ul>
<hr>
<h3>exportDefaultDeclaration</h3>
<pre class="hljs"><code>t.exportDefaultDeclaration(declaration)
</code></pre>
<p>See also <code>t.isExportDefaultDeclaration(node, opts)</code> and <code>t.assertExportDefaultDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code>: <code>FunctionDeclaration | ClassDeclaration | Expression</code> (required)</li>
</ul>
<hr>
<h3>exportDefaultSpecifier</h3>
<pre class="hljs"><code>t.exportDefaultSpecifier(exported)
</code></pre>
<p>See also <code>t.isExportDefaultSpecifier(node, opts)</code> and <code>t.assertExportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required)</li>
</ul>
<hr>
<h3>exportNamedDeclaration</h3>
<pre class="hljs"><code>t.exportNamedDeclaration(declaration, specifiers, source)
</code></pre>
<p>See also <code>t.isExportNamedDeclaration(node, opts)</code> and <code>t.assertExportNamedDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code>: <code>Declaration</code> (default: <code>null</code>)</li>
<li><code>specifiers</code>: <code>Array&lt;ExportSpecifier&gt;</code> (required)</li>
<li><code>source</code>: <code>StringLiteral</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>exportNamespaceSpecifier</h3>
<pre class="hljs"><code>t.exportNamespaceSpecifier(exported)
</code></pre>
<p>See also <code>t.isExportNamespaceSpecifier(node, opts)</code> and <code>t.assertExportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required)</li>
</ul>
<hr>
<h3>exportSpecifier</h3>
<pre class="hljs"><code>t.exportSpecifier(local, exported)
</code></pre>
<p>See also <code>t.isExportSpecifier(node, opts)</code> and <code>t.assertExportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>exported</code>: <code>Identifier</code> (required)</li>
</ul>
<hr>
<h3>expressionStatement</h3>
<pre class="hljs"><code>t.expressionStatement(expression)
</code></pre>
<p>See also <code>t.isExpressionStatement(node, opts)</code> and <code>t.assertExpressionStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>file</h3>
<pre class="hljs"><code>t.file(program, comments, tokens)
</code></pre>
<p>See also <code>t.isFile(node, opts)</code> and <code>t.assertFile(node, opts)</code>.</p>
<ul>
<li><code>program</code>: <code>Program</code> (required)</li>
<li><code>comments</code> (required)</li>
<li><code>tokens</code> (required)</li>
</ul>
<hr>
<h3>forAwaitStatement</h3>
<pre class="hljs"><code>t.forAwaitStatement(left, right, body)
</code></pre>
<p>See also <code>t.isForAwaitStatement(node, opts)</code> and <code>t.assertForAwaitStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>forInStatement</h3>
<pre class="hljs"><code>t.forInStatement(left, right, body)
</code></pre>
<p>See also <code>t.isForInStatement(node, opts)</code> and <code>t.assertForInStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>forOfStatement</h3>
<pre class="hljs"><code>t.forOfStatement(left, right, body)
</code></pre>
<p>See also <code>t.isForOfStatement(node, opts)</code> and <code>t.assertForOfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>forStatement</h3>
<pre class="hljs"><code>t.forStatement(init, test, update, body)
</code></pre>
<p>See also <code>t.isForStatement(node, opts)</code> and <code>t.assertForStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code></p>
<ul>
<li><code>init</code>: <code>VariableDeclaration | Expression</code> (default: <code>null</code>)</li>
<li><code>test</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>update</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>functionDeclaration</h3>
<pre class="hljs"><code>t.functionDeclaration(id, params, body, generator, <span class="hljs-keyword">async</span>)
</code></pre>
<p>See also <code>t.isFunctionDeclaration(node, opts)</code> and <code>t.assertFunctionDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Statement</code>, <code>Pureish</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>functionExpression</h3>
<pre class="hljs"><code>t.functionExpression(id, params, body, generator, <span class="hljs-keyword">async</span>)
</code></pre>
<p>See also <code>t.isFunctionExpression(node, opts)</code> and <code>t.assertFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>functionTypeAnnotation</h3>
<pre class="hljs"><code>t.functionTypeAnnotation(typeParameters, params, rest, returnType)
</code></pre>
<p>See also <code>t.isFunctionTypeAnnotation(node, opts)</code> and <code>t.assertFunctionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeParameters</code> (required)</li>
<li><code>params</code> (required)</li>
<li><code>rest</code> (required)</li>
<li><code>returnType</code> (required)</li>
</ul>
<hr>
<h3>functionTypeParam</h3>
<pre class="hljs"><code>t.functionTypeParam(name, typeAnnotation)
</code></pre>
<p>See also <code>t.isFunctionTypeParam(node, opts)</code> and <code>t.assertFunctionTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>name</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<hr>
<h3>genericTypeAnnotation</h3>
<pre class="hljs"><code>t.genericTypeAnnotation(id, typeParameters)
</code></pre>
<p>See also <code>t.isGenericTypeAnnotation(node, opts)</code> and <code>t.assertGenericTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<hr>
<h3>identifier</h3>
<pre class="hljs"><code>t.identifier(name)
</code></pre>
<p>See also <code>t.isIdentifier(node, opts)</code> and <code>t.assertIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>name``string</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
<li><code>typeAnnotation</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>ifStatement</h3>
<pre class="hljs"><code>t.ifStatement(test, consequent, alternate)
</code></pre>
<p>See also <code>t.isIfStatement(node, opts)</code> and <code>t.assertIfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Statement</code> (required)</li>
<li><code>alternate</code>: <code>Statement</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>import</h3>
<pre class="hljs"><code>t.import()
</code></pre>
<p>See also <code>t.isImport(node, opts)</code> and <code>t.assertImport(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr>
<h3>importDeclaration</h3>
<pre class="hljs"><code>t.importDeclaration(specifiers, source)
</code></pre>
<p>See also <code>t.isImportDeclaration(node, opts)</code> and <code>t.assertImportDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code></p>
<ul>
<li><code>specifiers</code>: <code>Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;</code> (required)</li>
<li><code>source</code>: <code>StringLiteral</code> (required)</li>
</ul>
<hr>
<h3>importDefaultSpecifier</h3>
<pre class="hljs"><code>t.importDefaultSpecifier(local)
</code></pre>
<p>See also <code>t.isImportDefaultSpecifier(node, opts)</code> and <code>t.assertImportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
</ul>
<hr>
<h3>importNamespaceSpecifier</h3>
<pre class="hljs"><code>t.importNamespaceSpecifier(local)
</code></pre>
<p>See also <code>t.isImportNamespaceSpecifier(node, opts)</code> and <code>t.assertImportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
</ul>
<hr>
<h3>importSpecifier</h3>
<pre class="hljs"><code>t.importSpecifier(local, imported)
</code></pre>
<p>See also <code>t.isImportSpecifier(node, opts)</code> and <code>t.assertImportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>imported</code>: <code>Identifier</code> (required)</li>
<li><code>importKind</code>: <code>null | &apos;type&apos; | &apos;typeof&apos;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>interfaceDeclaration</h3>
<pre class="hljs"><code>t.interfaceDeclaration(id, typeParameters, <span class="hljs-keyword">extends</span>, body)
</code></pre>
<p>See also <code>t.isInterfaceDeclaration(node, opts)</code> and <code>t.assertInterfaceDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required)</li>
</ul>
<hr>
<h3>interfaceExtends</h3>
<pre class="hljs"><code>t.interfaceExtends(id, typeParameters)
</code></pre>
<p>See also <code>t.isInterfaceExtends(node, opts)</code> and <code>t.assertInterfaceExtends(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
</ul>
<hr>
<h3>intersectionTypeAnnotation</h3>
<pre class="hljs"><code>t.intersectionTypeAnnotation(types)
</code></pre>
<p>See also <code>t.isIntersectionTypeAnnotation(node, opts)</code> and <code>t.assertIntersectionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<hr>
<h3>jSXAttribute</h3>
<pre class="hljs"><code>t.jSXAttribute(name, value)
</code></pre>
<p>See also <code>t.isJSXAttribute(node, opts)</code> and <code>t.assertJSXAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXNamespacedName</code> (required)</li>
<li><code>value</code>: <code>JSXElement | StringLiteral | JSXExpressionContainer</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>jSXClosingElement</h3>
<pre class="hljs"><code>t.jSXClosingElement(name)
</code></pre>
<p>See also <code>t.isJSXClosingElement(node, opts)</code> and <code>t.assertJSXClosingElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
</ul>
<hr>
<h3>jSXElement</h3>
<pre class="hljs"><code>t.jSXElement(openingElement, closingElement, children, selfClosing)
</code></pre>
<p>See also <code>t.isJSXElement(node, opts)</code> and <code>t.assertJSXElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code>, <code>Expression</code></p>
<ul>
<li><code>openingElement</code>: <code>JSXOpeningElement</code> (required)</li>
<li><code>closingElement</code>: <code>JSXClosingElement</code> (default: <code>null</code>)</li>
<li><code>children</code>: <code>Array&lt;JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement&gt;</code> (required)</li>
<li><code>selfClosing</code> (required)</li>
</ul>
<hr>
<h3>jSXEmptyExpression</h3>
<pre class="hljs"><code>t.jSXEmptyExpression()
</code></pre>
<p>See also <code>t.isJSXEmptyExpression(node, opts)</code> and <code>t.assertJSXEmptyExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<hr>
<h3>jSXExpressionContainer</h3>
<pre class="hljs"><code>t.jSXExpressionContainer(expression)
</code></pre>
<p>See also <code>t.isJSXExpressionContainer(node, opts)</code> and <code>t.assertJSXExpressionContainer(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>jSXIdentifier</h3>
<pre class="hljs"><code>t.jSXIdentifier(name)
</code></pre>
<p>See also <code>t.isJSXIdentifier(node, opts)</code> and <code>t.assertJSXIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>name</code>: <code>string</code> (required)</li>
</ul>
<hr>
<h3>jSXMemberExpression</h3>
<pre class="hljs"><code>t.jSXMemberExpression(object, property)
</code></pre>
<p>See also <code>t.isJSXMemberExpression(node, opts)</code> and <code>t.assertJSXMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>object</code>: <code>JSXMemberExpression | JSXIdentifier</code> (required)</li>
<li><code>property</code>: <code>JSXIdentifier</code> (required)</li>
</ul>
<hr>
<h3>jSXNamespacedName</h3>
<pre class="hljs"><code>t.jSXNamespacedName(namespace, name)
</code></pre>
<p>See also <code>t.isJSXNamespacedName(node, opts)</code> and <code>t.assertJSXNamespacedName(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>namespace</code>: <code>JSXIdentifier</code> (required)</li>
<li><code>name</code>: <code>JSXIdentifier</code> (required)</li>
</ul>
<hr>
<h3>jSXOpeningElement</h3>
<pre class="hljs"><code>t.jSXOpeningElement(name, attributes, selfClosing)
</code></pre>
<p>See also <code>t.isJSXOpeningElement(node, opts)</code> and <code>t.assertJSXOpeningElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
<li><code>attributes</code>: <code>Array&lt;JSXAttribute | JSXSpreadAttribute&gt;</code> (required)</li>
<li><code>selfClosing</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<h3>jSXSpreadAttribute</h3>
<pre class="hljs"><code>t.jSXSpreadAttribute(argument)
</code></pre>
<p>See also <code>t.isJSXSpreadAttribute(node, opts)</code> and <code>t.assertJSXSpreadAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>jSXSpreadChild</h3>
<pre class="hljs"><code>t.jSXSpreadChild(expression)
</code></pre>
<p>See also <code>t.isJSXSpreadChild(node, opts)</code> and <code>t.assertJSXSpreadChild(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>jSXText</h3>
<pre class="hljs"><code>t.jSXText(value)
</code></pre>
<p>See also <code>t.isJSXText(node, opts)</code> and <code>t.assertJSXText(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<hr>
<h3>labeledStatement</h3>
<pre class="hljs"><code>t.labeledStatement(label, body)
</code></pre>
<p>See also <code>t.isLabeledStatement(node, opts)</code> and <code>t.assertLabeledStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required)</li>
</ul>
<hr>
<h3>logicalExpression</h3>
<pre class="hljs"><code>t.logicalExpression(operator, left, right)
</code></pre>
<p>See also <code>t.isLogicalExpression(node, opts)</code> and <code>t.assertLogicalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>&apos;||&apos; | &apos;&amp;&amp;&apos;</code> (required)</li>
<li><code>left</code>: <code>Expression</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>memberExpression</h3>
<pre class="hljs"><code>t.memberExpression(object, property, computed)
</code></pre>
<p>See also <code>t.isMemberExpression(node, opts)</code> and <code>t.assertMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>object</code>: <code>Expression</code> (required)</li>
<li><code>property</code>if computed then <code>Expression</code> else <code>Identifier</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<h3>metaProperty</h3>
<pre class="hljs"><code>t.metaProperty(meta, property)
</code></pre>
<p>See also <code>t.isMetaProperty(node, opts)</code> and <code>t.assertMetaProperty(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>meta</code>: <code>string</code> (required)</li>
<li><code>property</code>: <code>string</code> (required)</li>
</ul>
<hr>
<h3>mixedTypeAnnotation</h3>
<pre class="hljs"><code>t.mixedTypeAnnotation()
</code></pre>
<p>See also <code>t.isMixedTypeAnnotation(node, opts)</code> and <code>t.assertMixedTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>newExpression</h3>
<pre class="hljs"><code>t.newExpression(callee, <span class="hljs-built_in">arguments</span>)
</code></pre>
<p>See also <code>t.isNewExpression(node, opts)</code> and <code>t.assertNewExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>Array&lt;Expression | SpreadElement&gt;</code> (required)</li>
</ul>
<hr>
<h3>noop</h3>
<pre class="hljs"><code>t.noop()
</code></pre>
<p>See also <code>t.isNoop(node, opts)</code> and <code>t.assertNoop(node, opts)</code>.</p>
<hr>
<h3>nullLiteral</h3>
<pre class="hljs"><code>t.nullLiteral()
</code></pre>
<p>See also <code>t.isNullLiteral(node, opts)</code> and <code>t.assertNullLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<hr>
<h3>nullLiteralTypeAnnotation</h3>
<pre class="hljs"><code>t.nullLiteralTypeAnnotation()
</code></pre>
<p>See also <code>t.isNullLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNullLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>nullableTypeAnnotation</h3>
<pre class="hljs"><code>t.nullableTypeAnnotation(typeAnnotation)
</code></pre>
<p>See also <code>t.isNullableTypeAnnotation(node, opts)</code> and <code>t.assertNullableTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<hr>
<h3>numberTypeAnnotation</h3>
<pre class="hljs"><code>t.numberTypeAnnotation()
</code></pre>
<p>See also <code>t.isNumberTypeAnnotation(node, opts)</code> and <code>t.assertNumberTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>numericLiteral</h3>
<pre class="hljs"><code>t.numericLiteral(value)
</code></pre>
<p>See also <code>t.isNumericLiteral(node, opts)</code> and <code>t.assertNumericLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>number</code> (required)</li>
</ul>
<hr>
<h3>numericLiteralTypeAnnotation</h3>
<pre class="hljs"><code>t.numericLiteralTypeAnnotation()
</code></pre>
<p>See also <code>t.isNumericLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNumericLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr>
<h3>objectExpression</h3>
<pre class="hljs"><code>t.objectExpression(properties)
</code></pre>
<p>See also <code>t.isObjectExpression(node, opts)</code> and <code>t.assertObjectExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;ObjectMethod | ObjectProperty | SpreadProperty&gt;</code> (required)</li>
</ul>
<hr>
<h3>objectMethod</h3>
<pre class="hljs"><code>t.objectMethod(kind, key, params, body, computed)
</code></pre>
<p>See also <code>t.isObjectMethod(node, opts)</code> and <code>t.assertObjectMethod(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code>, <code>ObjectMember</code></p>
<ul>
<li><code>kind</code>: <code>&quot;method&quot; | &quot;get&quot; | &quot;set&quot;</code> (default: <code>&apos;method&apos;</code>)</li>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>params</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>objectPattern</h3>
<pre class="hljs"><code>t.objectPattern(properties, typeAnnotation)
</code></pre>
<p>See also <code>t.isObjectPattern(node, opts)</code> and <code>t.assertObjectPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;RestProperty | Property&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>objectProperty</h3>
<pre class="hljs"><code>t.objectProperty(key, value, computed, shorthand, decorators)
</code></pre>
<p>See also <code>t.isObjectProperty(node, opts)</code> and <code>t.assertObjectProperty(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Property</code>, <code>ObjectMember</code></p>
<ul>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>value</code>: <code>Expression | Pattern | RestElement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>shorthand</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>objectTypeAnnotation</h3>
<pre class="hljs"><code>t.objectTypeAnnotation(properties, indexers, callProperties)
</code></pre>
<p>See also <code>t.isObjectTypeAnnotation(node, opts)</code> and <code>t.assertObjectTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>properties</code> (required)</li>
<li><code>indexers</code> (required)</li>
<li><code>callProperties</code> (required)</li>
</ul>
<hr>
<h3>objectTypeCallProperty</h3>
<pre class="hljs"><code>t.objectTypeCallProperty(value)
</code></pre>
<p>See also <code>t.isObjectTypeCallProperty(node, opts)</code> and <code>t.assertObjectTypeCallProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>value</code> (required)</li>
</ul>
<hr>
<h3>objectTypeIndexer</h3>
<pre class="hljs"><code>t.objectTypeIndexer(id, key, value)
</code></pre>
<p>See also <code>t.isObjectTypeIndexer(node, opts)</code> and <code>t.assertObjectTypeIndexer(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
</ul>
<hr>
<h3>objectTypeProperty</h3>
<pre class="hljs"><code>t.objectTypeProperty(key, value)
</code></pre>
<p>See also <code>t.isObjectTypeProperty(node, opts)</code> and <code>t.assertObjectTypeProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
</ul>
<hr>
<h3>objectTypeSpreadProperty</h3>
<pre class="hljs"><code>t.objectTypeSpreadProperty(argument)
</code></pre>
<p>See also <code>t.isObjectTypeSpreadProperty(node, opts)</code> and <code>t.assertObjectTypeSpreadProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>argument</code> (required)</li>
</ul>
<hr>
<h3>opaqueType</h3>
<pre class="hljs"><code>t.opaqueType(id, typeParameters, impltype, supertype)
</code></pre>
<p>See also <code>t.isOpaqueType(node, opts)</code> and <code>t.assertOpaqueType(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>impltype</code> (required)</li>
<li><code>supertype</code> (required)</li>
</ul>
<hr>
<h3>parenthesizedExpression</h3>
<pre class="hljs"><code>t.parenthesizedExpression(expression)
</code></pre>
<p>See also <code>t.isParenthesizedExpression(node, opts)</code> and <code>t.assertParenthesizedExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>program</h3>
<pre class="hljs"><code>t.program(body, directives)
</code></pre>
<p>See also <code>t.isProgram(node, opts)</code> and <code>t.assertProgram(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>FunctionParent</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>)</li>
</ul>
<hr>
<h3>qualifiedTypeIdentifier</h3>
<pre class="hljs"><code>t.qualifiedTypeIdentifier(id, qualification)
</code></pre>
<p>See also <code>t.isQualifiedTypeIdentifier(node, opts)</code> and <code>t.assertQualifiedTypeIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>qualification</code> (required)</li>
</ul>
<hr>
<h3>regExpLiteral</h3>
<pre class="hljs"><code>t.regExpLiteral(pattern, flags)
</code></pre>
<p>See also <code>t.isRegExpLiteral(node, opts)</code> and <code>t.assertRegExpLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>pattern</code>: <code>string</code> (required)</li>
<li><code>flags</code>: <code>string</code> (default: <code>&apos;&apos;</code>)</li>
</ul>
<hr>
<h3>restElement</h3>
<pre class="hljs"><code>t.restElement(argument, typeAnnotation)
</code></pre>
<p>See also <code>t.isRestElement(node, opts)</code> and <code>t.assertRestElement(node, opts)</code>.</p>
<p>Aliases: <code>LVal</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>restProperty</h3>
<pre class="hljs"><code>t.restProperty(argument)
</code></pre>
<p>See also <code>t.isRestProperty(node, opts)</code> and <code>t.assertRestProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required)</li>
</ul>
<hr>
<h3>returnStatement</h3>
<pre class="hljs"><code>t.returnStatement(argument)
</code></pre>
<p>See also <code>t.isReturnStatement(node, opts)</code> and <code>t.assertReturnStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>sequenceExpression</h3>
<pre class="hljs"><code>t.sequenceExpression(expressions)
</code></pre>
<p>See also <code>t.isSequenceExpression(node, opts)</code> and <code>t.assertSequenceExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>expressions</code>: <code>Array&lt;Expression&gt;</code> (required)</li>
</ul>
<hr>
<h3>spreadElement</h3>
<pre class="hljs"><code>t.spreadElement(argument)
</code></pre>
<p>See also <code>t.isSpreadElement(node, opts)</code> and <code>t.assertSpreadElement(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>spreadProperty</h3>
<pre class="hljs"><code>t.spreadProperty(argument)
</code></pre>
<p>See also <code>t.isSpreadProperty(node, opts)</code> and <code>t.assertSpreadProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>stringLiteral</h3>
<pre class="hljs"><code>t.stringLiteral(value)
</code></pre>
<p>See also <code>t.isStringLiteral(node, opts)</code> and <code>t.assertStringLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required)</li>
</ul>
<hr>
<h3>stringLiteralTypeAnnotation</h3>
<pre class="hljs"><code>t.stringLiteralTypeAnnotation()
</code></pre>
<p>See also <code>t.isStringLiteralTypeAnnotation(node, opts)</code> and <code>t.assertStringLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr>
<h3>stringTypeAnnotation</h3>
<pre class="hljs"><code>t.stringTypeAnnotation()
</code></pre>
<p>See also <code>t.isStringTypeAnnotation(node, opts)</code> and <code>t.assertStringTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>super</h3>
<pre class="hljs"><code>t.super()
</code></pre>
<p>See also <code>t.isSuper(node, opts)</code> and <code>t.assertSuper(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr>
<h3>switchCase</h3>
<pre class="hljs"><code>t.switchCase(test, consequent)
</code></pre>
<p>See also <code>t.isSwitchCase(node, opts)</code> and <code>t.assertSwitchCase(node, opts)</code>.</p>
<ul>
<li><code>test</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>consequent</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
</ul>
<hr>
<h3>switchStatement</h3>
<pre class="hljs"><code>t.switchStatement(discriminant, cases)
</code></pre>
<p>See also <code>t.isSwitchStatement(node, opts)</code> and <code>t.assertSwitchStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Scopable</code></p>
<ul>
<li><code>discriminant</code>: <code>Expression</code> (required)</li>
<li><code>cases</code>: <code>Array&lt;SwitchCase&gt;</code> (required)</li>
</ul>
<hr>
<h3>taggedTemplateExpression</h3>
<pre class="hljs"><code>t.taggedTemplateExpression(tag, quasi)
</code></pre>
<p>See also <code>t.isTaggedTemplateExpression(node, opts)</code> and <code>t.assertTaggedTemplateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>tag</code>: <code>Expression</code> (required)</li>
<li><code>quasi</code>: <code>TemplateLiteral</code> (required)</li>
</ul>
<hr>
<h3>templateElement</h3>
<pre class="hljs"><code>t.templateElement(value, tail)
</code></pre>
<p>See also <code>t.isTemplateElement(node, opts)</code> and <code>t.assertTemplateElement(node, opts)</code>.</p>
<ul>
<li><code>value</code> (required)</li>
<li><code>tail</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<h3>templateLiteral</h3>
<pre class="hljs"><code>t.templateLiteral(quasis, expressions)
</code></pre>
<p>See also <code>t.isTemplateLiteral(node, opts)</code> and <code>t.assertTemplateLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>quasis</code>: <code>Array&lt;TemplateElement&gt;</code> (required)</li>
<li><code>expressions</code>: <code>Array&lt;Expression&gt;</code> (required)</li>
</ul>
<hr>
<h3>thisExpression</h3>
<pre class="hljs"><code>t.thisExpression()
</code></pre>
<p>See also <code>t.isThisExpression(node, opts)</code> and <code>t.assertThisExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr>
<h3>thisTypeAnnotation</h3>
<pre class="hljs"><code>t.thisTypeAnnotation()
</code></pre>
<p>See also <code>t.isThisTypeAnnotation(node, opts)</code> and <code>t.assertThisTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>throwStatement</h3>
<pre class="hljs"><code>t.throwStatement(argument)
</code></pre>
<p>See also <code>t.isThrowStatement(node, opts)</code> and <code>t.assertThrowStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required)</li>
</ul>
<hr>
<h3>tryStatement</h3>
<pre class="hljs"><code>t.tryStatement(block, handler, finalizer)
</code></pre>
<p>See also <code>t.isTryStatement(node, opts)</code> and <code>t.assertTryStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>block</code> (required)</li>
<li><code>handler</code> (default: <code>null</code>)</li>
<li><code>finalizer</code>: <code>BlockStatement</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>BlockStatement</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>tupleTypeAnnotation</h3>
<pre class="hljs"><code>t.tupleTypeAnnotation(types)
</code></pre>
<p>See also <code>t.isTupleTypeAnnotation(node, opts)</code> and <code>t.assertTupleTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<hr>
<h3>typeAlias</h3>
<pre class="hljs"><code>t.typeAlias(id, typeParameters, right)
</code></pre>
<p>See also <code>t.isTypeAlias(node, opts)</code> and <code>t.assertTypeAlias(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>right</code> (required)</li>
</ul>
<hr>
<h3>typeAnnotation</h3>
<pre class="hljs"><code>t.typeAnnotation(typeAnnotation)
</code></pre>
<p>See also <code>t.isTypeAnnotation(node, opts)</code> and <code>t.assertTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<hr>
<h3>typeCastExpression</h3>
<pre class="hljs"><code>t.typeCastExpression(expression, typeAnnotation)
</code></pre>
<p>See also <code>t.isTypeCastExpression(node, opts)</code> and <code>t.assertTypeCastExpression(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>ExpressionWrapper</code>, <code>Expression</code></p>
<ul>
<li><code>expression</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
</ul>
<hr>
<h3>typeParameter</h3>
<pre class="hljs"><code>t.typeParameter(bound)
</code></pre>
<p>See also <code>t.isTypeParameter(node, opts)</code> and <code>t.assertTypeParameter(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>bound</code> (required)</li>
</ul>
<hr>
<h3>typeParameterDeclaration</h3>
<pre class="hljs"><code>t.typeParameterDeclaration(params)
</code></pre>
<p>See also <code>t.isTypeParameterDeclaration(node, opts)</code> and <code>t.assertTypeParameterDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required)</li>
</ul>
<hr>
<h3>typeParameterInstantiation</h3>
<pre class="hljs"><code>t.typeParameterInstantiation(params)
</code></pre>
<p>See also <code>t.isTypeParameterInstantiation(node, opts)</code> and <code>t.assertTypeParameterInstantiation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required)</li>
</ul>
<hr>
<h3>typeofTypeAnnotation</h3>
<pre class="hljs"><code>t.typeofTypeAnnotation(argument)
</code></pre>
<p>See also <code>t.isTypeofTypeAnnotation(node, opts)</code> and <code>t.assertTypeofTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>argument</code> (required)</li>
</ul>
<hr>
<h3>unaryExpression</h3>
<pre class="hljs"><code>t.unaryExpression(operator, argument, prefix)
</code></pre>
<p>See also <code>t.isUnaryExpression(node, opts)</code> and <code>t.assertUnaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>&apos;void&apos; | &apos;delete&apos; | &apos;!&apos; | &apos;+&apos; | &apos;-&apos; | &apos;++&apos; | &apos;--&apos; | &apos;~&apos; | &apos;typeof&apos;</code> (required)</li>
<li><code>argument</code>: <code>Expression</code> (required)</li>
<li><code>prefix</code>: <code>boolean</code> (default: <code>true</code>)</li>
</ul>
<hr>
<h3>unionTypeAnnotation</h3>
<pre class="hljs"><code>t.unionTypeAnnotation(types)
</code></pre>
<p>See also <code>t.isUnionTypeAnnotation(node, opts)</code> and <code>t.assertUnionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required)</li>
</ul>
<hr>
<h3>updateExpression</h3>
<pre class="hljs"><code>t.updateExpression(operator, argument, prefix)
</code></pre>
<p>See also <code>t.isUpdateExpression(node, opts)</code> and <code>t.assertUpdateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>&apos;++&apos; | &apos;--&apos;</code> (required)</li>
<li><code>argument</code>: <code>Expression</code> (required)</li>
<li><code>prefix</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<h3>variableDeclaration</h3>
<pre class="hljs"><code>t.variableDeclaration(kind, declarations)
</code></pre>
<p>See also <code>t.isVariableDeclaration(node, opts)</code> and <code>t.assertVariableDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>kind</code>: <code>&quot;var&quot; | &quot;let&quot; | &quot;const&quot;</code> (required)</li>
<li><code>declarations</code>: <code>Array&lt;VariableDeclarator&gt;</code> (required)</li>
</ul>
<hr>
<h3>variableDeclarator</h3>
<pre class="hljs"><code>t.variableDeclarator(id, init)
</code></pre>
<p>See also <code>t.isVariableDeclarator(node, opts)</code> and <code>t.assertVariableDeclarator(node, opts)</code>.</p>
<ul>
<li><code>id</code>: <code>LVal</code> (required)</li>
<li><code>init</code>: <code>Expression</code> (default: <code>null</code>)</li>
</ul>
<hr>
<h3>voidTypeAnnotation</h3>
<pre class="hljs"><code>t.voidTypeAnnotation()
</code></pre>
<p>See also <code>t.isVoidTypeAnnotation(node, opts)</code> and <code>t.assertVoidTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr>
<h3>whileStatement</h3>
<pre class="hljs"><code>t.whileStatement(test, body)
</code></pre>
<p>See also <code>t.isWhileStatement(node, opts)</code> and <code>t.assertWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Statement</code> (required)</li>
</ul>
<hr>
<h3>withStatement</h3>
<pre class="hljs"><code>t.withStatement(object, body)
</code></pre>
<p>See also <code>t.isWithStatement(node, opts)</code> and <code>t.assertWithStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>object</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Statement</code> (required)</li>
</ul>
<hr>
<h3>yieldExpression</h3>
<pre class="hljs"><code>t.yieldExpression(argument, delegate)
</code></pre>
<p>See also <code>t.isYieldExpression(node, opts)</code> and <code>t.assertYieldExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>delegate</code>: <code>boolean</code> (default: <code>false</code>)</li>
</ul>
<hr>
<!-- end generated section -->
</body></html></div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../assets/js/index.js"></script>
  </body>
</html>
