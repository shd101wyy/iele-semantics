<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="IELE Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../assets/img/favicon.ico" />

<title>IELE Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../assets/img/iele-logo.png"
      alt="K"
      style="height: 48px"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/iele-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../Design">Design</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><p>A light, featureful and explicit option parsing library for node.js.</p>
<p><a href="#why">Why another one? See below</a>. tl;dr: The others I&apos;ve tried are one of
too loosey goosey (not explicit), too big/too many deps, or ill specified.
YMMV.</p>
<p>Follow <a href="https://twitter.com/intent/user?screen_name=trentmick" target="_blank" rel="noopener">@trentmick</a>
for updates to node-dashdash.</p>
<h1>Install</h1>
<pre><code>npm install dashdash
</code></pre>
<h1>Usage</h1>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dashdash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;dashdash&apos;</span>);

<span class="hljs-comment">// Specify the options. Minimally `name` (or `names`) and `type`</span>
<span class="hljs-comment">// must be given for each.</span>
<span class="hljs-keyword">var</span> options = [
    {
        <span class="hljs-comment">// `names` or a single `name`. First element is the `opts.KEY`.</span>
        <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;help&apos;</span>, <span class="hljs-string">&apos;h&apos;</span>],
        <span class="hljs-comment">// See &quot;Option specs&quot; below for types.</span>
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;bool&apos;</span>,
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Print this help and exit.&apos;</span>
    }
];

<span class="hljs-comment">// Shortcut form. As called it infers `process.argv`. See below for</span>
<span class="hljs-comment">// the longer form to use methods like `.help()` on the Parser object.</span>
<span class="hljs-keyword">var</span> opts = dashdash.parse({<span class="hljs-attr">options</span>: options});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;opts:&quot;</span>, opts);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;args:&quot;</span>, opts._args);
</code></pre>
<h1>Longer Example</h1>
<p>A more realistic <a href="./examples/foo.js">starter script &quot;foo.js&quot;</a> is as follows.
This also shows using <code>parser.help()</code> for formatted option help.</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> dashdash = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./lib/dashdash&apos;</span>);

<span class="hljs-keyword">var</span> options = [
    {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&apos;version&apos;</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;bool&apos;</span>,
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Print tool version and exit.&apos;</span>
    },
    {
        <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;help&apos;</span>, <span class="hljs-string">&apos;h&apos;</span>],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;bool&apos;</span>,
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Print this help and exit.&apos;</span>
    },
    {
        <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;verbose&apos;</span>, <span class="hljs-string">&apos;v&apos;</span>],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;arrayOfBool&apos;</span>,
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Verbose output. Use multiple times for more verbose.&apos;</span>
    },
    {
        <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;file&apos;</span>, <span class="hljs-string">&apos;f&apos;</span>],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;string&apos;</span>,
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;File to process&apos;</span>,
        <span class="hljs-attr">helpArg</span>: <span class="hljs-string">&apos;FILE&apos;</span>
    }
];

<span class="hljs-keyword">var</span> parser = dashdash.createParser({<span class="hljs-attr">options</span>: options});
<span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">var</span> opts = parser.parse(process.argv);
} <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&apos;foo: error: %s&apos;</span>, e.message);
    process.exit(<span class="hljs-number">1</span>);
}

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;# opts:&quot;</span>, opts);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;# args:&quot;</span>, opts._args);

<span class="hljs-comment">// Use `parser.help()` for formatted options help.</span>
<span class="hljs-keyword">if</span> (opts.help) {
    <span class="hljs-keyword">var</span> help = parser.help({<span class="hljs-attr">includeEnv</span>: <span class="hljs-literal">true</span>}).trimRight();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;usage: node foo.js [OPTIONS]\n&apos;</span>
                + <span class="hljs-string">&apos;options:\n&apos;</span>
                + help);
    process.exit(<span class="hljs-number">0</span>);
}

<span class="hljs-comment">// ...</span>
</code></pre>
<p>Some example output from this script (foo.js):</p>
<pre class="hljs"><code>$ node foo.js -h
# opts: { help: true,
  _order: [ { name: &apos;help&apos;, value: true, from: &apos;argv&apos; } ],
  _args: [] }
# args: []
usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
    -f FILE, --file=FILE  File to process

$ node foo.js -v
# opts: { verbose: [ true ],
  _order: [ { name: &apos;verbose&apos;, value: true, from: &apos;argv&apos; } ],
  _args: [] }
# args: []

$ node foo.js --version arg1
# opts: { version: true,
  _order: [ { name: &apos;version&apos;, value: true, from: &apos;argv&apos; } ],
  _args: [ &apos;arg1&apos; ] }
# args: [ &apos;arg1&apos; ]

$ node foo.js -f bar.txt
# opts: { file: &apos;bar.txt&apos;,
  _order: [ { name: &apos;file&apos;, value: &apos;bar.txt&apos;, from: &apos;argv&apos; } ],
  _args: [] }
# args: []

$ node foo.js -vvv --file=blah
# opts: { verbose: [ true, true, true ],
  file: &apos;blah&apos;,
  _order:
   [ { name: &apos;verbose&apos;, value: true, from: &apos;argv&apos; },
     { name: &apos;verbose&apos;, value: true, from: &apos;argv&apos; },
     { name: &apos;verbose&apos;, value: true, from: &apos;argv&apos; },
     { name: &apos;file&apos;, value: &apos;blah&apos;, from: &apos;argv&apos; } ],
  _args: [] }
# args: []
</code></pre>
<p>See the <a href="examples/">&quot;examples&quot;</a> dir for a number of starter examples using
some of dashdash&apos;s features.</p>
<h1>Environment variable integration</h1>
<p>If you want to allow environment variables to specify options to your tool,
dashdash makes this easy. We can change the &apos;verbose&apos; option in the example
above to include an &apos;env&apos; field:</p>
<pre class="hljs"><code>    {
        <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;verbose&apos;</span>, <span class="hljs-string">&apos;v&apos;</span>],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;arrayOfBool&apos;</span>,
        <span class="hljs-attr">env</span>: <span class="hljs-string">&apos;FOO_VERBOSE&apos;</span>,         <span class="hljs-comment">// &lt;--- add this line</span>
        <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Verbose output. Use multiple times for more verbose.&apos;</span>
    },
</code></pre>
<p>then the <strong>&quot;FOO_VERBOSE&quot; environment variable</strong> can be used to set this
option:</p>
<pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> FOO_VERBOSE=1 node foo.js</span>
<span class="hljs-meta">#</span><span class="bash"> opts: { verbose: [ <span class="hljs-literal">true</span> ],</span>
  _order: [ { name: &apos;verbose&apos;, value: true, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
</code></pre>
<p>Boolean options will interpret the empty string as unset, &apos;0&apos; as false
and anything else as true.</p>
<pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> FOO_VERBOSE= node examples/foo.js                 <span class="hljs-comment"># not set</span></span>
<span class="hljs-meta">#</span><span class="bash"> opts: { _order: [], _args: [] }</span>
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
<span class="hljs-meta">
$</span><span class="bash"> FOO_VERBOSE=0 node examples/foo.js                <span class="hljs-comment"># &apos;0&apos; is false</span></span>
<span class="hljs-meta">#</span><span class="bash"> opts: { verbose: [ <span class="hljs-literal">false</span> ],</span>
  _order: [ { key: &apos;verbose&apos;, value: false, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
<span class="hljs-meta">
$</span><span class="bash"> FOO_VERBOSE=1 node examples/foo.js                <span class="hljs-comment"># true</span></span>
<span class="hljs-meta">#</span><span class="bash"> opts: { verbose: [ <span class="hljs-literal">true</span> ],</span>
  _order: [ { key: &apos;verbose&apos;, value: true, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
<span class="hljs-meta">
$</span><span class="bash"> FOO_VERBOSE=boogabooga node examples/foo.js       <span class="hljs-comment"># true</span></span>
<span class="hljs-meta">#</span><span class="bash"> opts: { verbose: [ <span class="hljs-literal">true</span> ],</span>
  _order: [ { key: &apos;verbose&apos;, value: true, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
</code></pre>
<p>Non-booleans can be used as well. Strings:</p>
<pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> FOO_FILE=data.txt node examples/foo.js</span>
<span class="hljs-meta">#</span><span class="bash"> opts: { file: <span class="hljs-string">&apos;data.txt&apos;</span>,</span>
  _order: [ { key: &apos;file&apos;, value: &apos;data.txt&apos;, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
</code></pre>
<p>Numbers:</p>
<pre class="hljs"><code><span class="hljs-meta">$</span><span class="bash"> FOO_TIMEOUT=5000 node examples/foo.js</span>
<span class="hljs-meta">#</span><span class="bash"> opts: { timeout: 5000,</span>
  _order: [ { key: &apos;timeout&apos;, value: 5000, from: &apos;env&apos; } ],
  _args: [] }
<span class="hljs-meta">#</span><span class="bash"> args: []</span>
<span class="hljs-meta">
$</span><span class="bash"> FOO_TIMEOUT=blarg node examples/foo.js</span>
foo: error: arg for &quot;FOO_TIMEOUT&quot; is not a positive integer: &quot;blarg&quot;
</code></pre>
<p>With the <code>includeEnv: true</code> config to <code>parser.help()</code> the environment
variable can also be included in <strong>help output</strong>:</p>
<pre><code>usage: node foo.js [OPTIONS]
options:
    --version             Print tool version and exit.
    -h, --help            Print this help and exit.
    -v, --verbose         Verbose output. Use multiple times for more verbose.
                          Environment: FOO_VERBOSE=1
    -f FILE, --file=FILE  File to process
</code></pre>
<h1>Bash completion</h1>
<p>Dashdash provides a simple way to create a Bash completion file that you
can place in your &quot;bash_completion.d&quot; directory -- sometimes that is
&quot;/usr/local/etc/bash_completion.d/&quot;). Features:</p>
<ul>
<li>Support for short and long opts</li>
<li>Support for knowing which options take arguments</li>
<li>Support for subcommands (e.g. &apos;git log <tab>&apos; to show just options for the
log subcommand). See
<a href="https://github.com/trentm/node-cmdln#bash-completion" target="_blank" rel="noopener">node-cmdln</a> for
how to integrate that.</tab></li>
<li>Does the right thing with &quot;--&quot; to stop options.</li>
<li>Custom optarg and arg types for custom completions.</li>
</ul>
<p>Dashdash will return bash completion file content given a parser instance:</p>
<pre><code>var parser = dashdash.createParser({options: options});
console.log( parser.bashCompletion({name: &apos;mycli&apos;}) );
</code></pre>
<p>or directly from a <code>options</code> array of options specs:</p>
<pre><code>var code = dashdash.bashCompletionFromOptions({
    name: &apos;mycli&apos;,
    options: OPTIONS
});
</code></pre>
<p>Write that content to &quot;/usr/local/etc/bash_completion.d/mycli&quot; and you will
have Bash completions for <code>mycli</code>. Alternatively you can write it to
any file (e.g. &quot;~/.bashrc&quot;) and source it.</p>
<p>You could add a <code>--completion</code> hidden option to your tool that emits the
completion content and document for your users to call that to install
Bash completions.</p>
<p>See <a href="examples/ddcompletion.js">examples/ddcompletion.js</a> for a complete
example, including how one can define bash functions for completion of custom
option types. Also see <a href="https://github.com/trentm/node-cmdln" target="_blank" rel="noopener">node-cmdln</a> for
how it uses this for Bash completion for full multi-subcommand tools.</p>
<ul>
<li>TODO: document specExtra</li>
<li>TODO: document includeHidden</li>
<li>TODO: document custom types, <code>function complete\_FOO</code> guide, completionType</li>
<li>TODO: document argtypes</li>
</ul>
<h1>Parser config</h1>
<p>Parser construction (i.e. <code>dashdash.createParser(CONFIG)</code>) takes the
following fields:</p>
<ul>
<li>
<p><code>options</code> (Array of option specs). Required. See the
<a href="#option-specs">Option specs</a> section below.</p>
</li>
<li>
<p><code>interspersed</code> (Boolean). Optional. Default is true. If true this allows
interspersed arguments and options. I.e.:</p>
<pre><code>  node ./tool.js -v arg1 arg2 -h   # &apos;-h&apos; is after interspersed args
</code></pre>
<p>Set it to false to have &apos;-h&apos; <strong>not</strong> get parsed as an option in the above
example.</p>
</li>
<li>
<p><code>allowUnknown</code> (Boolean).  Optional.  Default is false.  If false, this causes
unknown arguments to throw an error.  I.e.:</p>
<pre><code>  node ./tool.js -v arg1 --afe8asefksjefhas
</code></pre>
<p>Set it to true to treat the unknown option as a positional
argument.</p>
<p><strong>Caveat</strong>: When a shortopt group, such as <code>-xaz</code> contains a mix of
known and unknown options, the <em>entire</em> group is passed through
unmolested as a positional argument.</p>
<p>Consider if you have a known short option <code>-a</code>, and parse the
following command line:</p>
<pre><code>  node ./tool.js -xaz
</code></pre>
<p>where <code>-x</code> and <code>-z</code> are unknown.  There are multiple ways to
interpret this:</p>
<ol>
<li><code>-x</code> takes a value: <code>{x: &apos;az&apos;}</code></li>
<li><code>-x</code> and <code>-z</code> are both booleans: <code>{x:true,a:true,z:true}</code></li>
</ol>
<p>Since dashdash does not know what <code>-x</code> and <code>-z</code> are, it can&apos;t know
if you&apos;d prefer to receive <code>{a:true,_args:[&apos;-x&apos;,&apos;-z&apos;]}</code> or
<code>{x:&apos;az&apos;}</code>, or <code>{_args:[&apos;-xaz&apos;]}</code>. Leaving the positional arg unprocessed
is the easiest mistake for the user to recover from.</p>
</li>
</ul>
<h1>Option specs</h1>
<p>Example using all fields (required fields are noted):</p>
<pre class="hljs"><code>{
    <span class="hljs-attr">names</span>: [<span class="hljs-string">&apos;file&apos;</span>, <span class="hljs-string">&apos;f&apos;</span>],       <span class="hljs-comment">// Required (one of `names` or `name`).</span>
    <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;string&apos;</span>,             <span class="hljs-comment">// Required.</span>
    <span class="hljs-attr">completionType</span>: <span class="hljs-string">&apos;filename&apos;</span>,
    <span class="hljs-attr">env</span>: <span class="hljs-string">&apos;MYTOOL_FILE&apos;</span>,
    <span class="hljs-attr">help</span>: <span class="hljs-string">&apos;Config file to load before running &quot;mytool&quot;&apos;</span>,
    <span class="hljs-attr">helpArg</span>: <span class="hljs-string">&apos;PATH&apos;</span>,
    <span class="hljs-attr">helpWrap</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">default</span>: path.resolve(process.env.HOME, <span class="hljs-string">&apos;.mytoolrc&apos;</span>)
}
</code></pre>
<p>Each option spec in the <code>options</code> array must/can have the following fields:</p>
<ul>
<li>
<p><code>name</code> (String) or <code>names</code> (Array). Required. These give the option name
and aliases. The first name (if more than one given) is the key for the
parsed <code>opts</code> object.</p>
</li>
<li>
<p><code>type</code> (String). Required. One of:</p>
<ul>
<li>bool</li>
<li>string</li>
<li>number</li>
<li>integer</li>
<li>positiveInteger</li>
<li>date (epoch seconds, e.g. 1396031701, or ISO 8601 format
<code>YYYY-MM-DD[THH:MM:SS[.sss][Z]]</code>, e.g. &quot;2014-03-28T18:35:01.489Z&quot;)</li>
<li>arrayOfBool</li>
<li>arrayOfString</li>
<li>arrayOfNumber</li>
<li>arrayOfInteger</li>
<li>arrayOfPositiveInteger</li>
<li>arrayOfDate</li>
</ul>
<p>FWIW, these names attempt to match with asserts on
<a href="https://github.com/mcavage/node-assert-plus" target="_blank" rel="noopener">assert-plus</a>.
You can add your own custom option types with <code>dashdash.addOptionType</code>.
See below.</p>
</li>
<li>
<p><code>completionType</code> (String). Optional. This is used for <a href="#bash-completion">Bash
completion</a> for an option argument. If not specified,
then the value of <code>type</code> is used. Any string may be specified, but only the
following values have meaning:</p>
<ul>
<li><code>none</code>: Provide no completions.</li>
<li><code>file</code>: Bash&apos;s default completion (i.e. <code>complete -o default</code>), which
includes filenames.</li>
<li><em>Any string FOO for which a <code>function complete_FOO</code> Bash function is
defined.</em> This is for custom completions for a given tool. Typically
these custom functions are provided in the <code>specExtra</code> argument to
<code>dashdash.bashCompletionFromOptions()</code>. See
<a href="examples/ddcompletion.js">&quot;examples/ddcompletion.js&quot;</a> for an example.</li>
</ul>
</li>
<li>
<p><code>env</code> (String or Array of String). Optional. An environment variable name
(or names) that can be used as a fallback for this option. For example,
given a &quot;foo.js&quot; like this:</p>
<pre><code>  var options = [{names: [&apos;dry-run&apos;, &apos;n&apos;], env: &apos;FOO_DRY_RUN&apos;}];
  var opts = dashdash.parse({options: options});
</code></pre>
<p>Both <code>node foo.js --dry-run</code> and <code>FOO_DRY_RUN=1 node foo.js</code> would result
in <code>opts.dry_run = true</code>.</p>
<p>An environment variable is only used as a fallback, i.e. it is ignored if
the associated option is given in <code>argv</code>.</p>
</li>
<li>
<p><code>help</code> (String). Optional. Used for <code>parser.help()</code> output.</p>
</li>
<li>
<p><code>helpArg</code> (String). Optional. Used in help output as the placeholder for
the option argument, e.g. the &quot;PATH&quot; in:</p>
<pre><code>  ...
  -f PATH, --file=PATH    File to process
  ...
</code></pre>
</li>
<li>
<p><code>helpWrap</code> (Boolean). Optional, default true. Set this to <code>false</code> to have
that option&apos;s <code>help</code> <em>not</em> be text wrapped in <code>&lt;parser&gt;.help()</code> output.</p>
</li>
<li>
<p><code>default</code>. Optional. A default value used for this option, if the
option isn&apos;t specified in argv.</p>
</li>
<li>
<p><code>hidden</code> (Boolean). Optional, default false. If true, help output will not
include this option. See also the <code>includeHidden</code> option to
<code>bashCompletionFromOptions()</code> for <a href="#bash-completion">Bash completion</a>.</p>
</li>
</ul>
<h1>Option group headings</h1>
<p>You can add headings between option specs in the <code>options</code> array.  To do so,
simply add an object with only a <code>group</code> property -- the string to print as
the heading for the subsequent options in the array.  For example:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> options = [
    {
        <span class="hljs-attr">group</span>: <span class="hljs-string">&apos;Armament Options&apos;</span>
    },
    {
        <span class="hljs-attr">names</span>: [ <span class="hljs-string">&apos;weapon&apos;</span>, <span class="hljs-string">&apos;w&apos;</span> ],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;string&apos;</span>
    },
    {
        <span class="hljs-attr">group</span>: <span class="hljs-string">&apos;General Options&apos;</span>
    },
    {
        <span class="hljs-attr">names</span>: [ <span class="hljs-string">&apos;help&apos;</span>, <span class="hljs-string">&apos;h&apos;</span> ],
        <span class="hljs-attr">type</span>: <span class="hljs-string">&apos;bool&apos;</span>
    }
];
...
</code></pre>
<p>Note: You can use an empty string, <code>{group: &apos;&apos;}</code>, to get a blank line in help
output between groups of options.</p>
<h1>Help config</h1>
<p>The <code>parser.help(...)</code> function is configurable as follows:</p>
<pre><code>    Options:
      Armament Options:
    ^^  -w WEAPON, --weapon=WEAPON  Weapon with which to crush. One of: |
   /                                sword, spear, maul                  |
  /   General Options:                                                  |
 /      -h, --help                  Print this help and exit.           |
/   ^^^^                            ^                                   |
\       `-- indent                   `-- helpCol              maxCol ---&apos;
 `-- headingIndent
</code></pre>
<ul>
<li><code>indent</code> (Number or String). Default 4. Set to a number (for that many
spaces) or a string for the literal indent.</li>
<li><code>headingIndent</code> (Number or String). Default half length of <code>indent</code>. Set to
a number (for that many spaces) or a string for the literal indent. This
indent applies to group heading lines, between normal option lines.</li>
<li><code>nameSort</code> (String). Default is &apos;length&apos;. By default the names are
sorted to put the short opts first (i.e. &apos;-h, --help&apos; preferred
to &apos;--help, -h&apos;). Set to &apos;none&apos; to not do this sorting.</li>
<li><code>maxCol</code> (Number). Default 80. Note that reflow is just done on whitespace
so a long token in the option help can overflow maxCol.</li>
<li><code>helpCol</code> (Number). If not set a reasonable value will be determined
between <code>minHelpCol</code> and <code>maxHelpCol</code>.</li>
<li><code>minHelpCol</code> (Number). Default 20.</li>
<li><code>maxHelpCol</code> (Number). Default 40.</li>
<li><code>helpWrap</code> (Boolean). Default true. Set to <code>false</code> to have option <code>help</code>
strings <em>not</em> be textwrapped to the helpCol..maxCol range.</li>
<li><code>includeEnv</code> (Boolean). Default false. If the option has associated
environment variables (via the <code>env</code> option spec attribute), then
append mentioned of those envvars to the help string.</li>
<li><code>includeDefault</code> (Boolean). Default false. If the option has a default value
(via the <code>default</code> option spec attribute, or a default on the option&apos;s type),
then a &quot;Default: VALUE&quot; string will be appended to the help string.</li>
</ul>
<h1>Custom option types</h1>
<p>Dashdash includes a good starter set of option types that it will parse for
you. However, you can add your own via:</p>
<pre><code>var dashdash = require(&apos;dashdash&apos;);
dashdash.addOptionType({
    name: &apos;...&apos;,
    takesArg: true,
    helpArg: &apos;...&apos;,
    parseArg: function (option, optstr, arg) {
        ...
    },
    array: false,  // optional
    arrayFlatten: false,  // optional
    default: ...,   // optional
    completionType: ...  // optional
});
</code></pre>
<p>For example, a simple option type that accepts &apos;yes&apos;, &apos;y&apos;, &apos;no&apos; or &apos;n&apos; as
a boolean argument would look like:</p>
<pre><code>var dashdash = require(&apos;dashdash&apos;);

function parseYesNo(option, optstr, arg) {
    var argLower = arg.toLowerCase()
    if (~[&apos;yes&apos;, &apos;y&apos;].indexOf(argLower)) {
        return true;
    } else if (~[&apos;no&apos;, &apos;n&apos;].indexOf(argLower)) {
        return false;
    } else {
        throw new Error(format(
            &apos;arg for &quot;%s&quot; is not &quot;yes&quot; or &quot;no&quot;: &quot;%s&quot;&apos;,
            optstr, arg));
    }
}

dashdash.addOptionType({
    name: &apos;yesno&apos;
    takesArg: true,
    helpArg: &apos;&lt;yes|no&gt;&apos;,
    parseArg: parseYesNo
});

var options = {
    {names: [&apos;answer&apos;, &apos;a&apos;], type: &apos;yesno&apos;}
};
var opts = dashdash.parse({options: options});
</code></pre>
<p>See &quot;examples/custom-option-*.js&quot; for other examples.
See the <code>addOptionType</code> block comment in &quot;lib/dashdash.js&quot; for more details.
Please let me know <a href="https://github.com/trentm/node-dashdash/issues/new" target="_blank" rel="noopener">with an
issue</a> if you write a
generally useful one.</p>
<h1>Why</h1>
<p>Why another node.js option parsing lib?</p>
<ul>
<li>
<p><code>nopt</code> really is just for &quot;tools like npm&quot;. Implicit opts (e.g. &apos;--no-foo&apos;
works for every &apos;--foo&apos;). Can&apos;t disable abbreviated opts. Can&apos;t do multiple
usages of same opt, e.g. &apos;-vvv&apos; (I think). Can&apos;t do grouped short opts.</p>
</li>
<li>
<p><code>optimist</code> has surprise interpretation of options (at least to me).
Implicit opts mean ambiguities and poor error handling for fat-fingering.
<code>process.exit</code> calls makes it hard to use as a libary.</p>
</li>
<li>
<p><code>optparse</code> Incomplete docs. Is this an attempted clone of Python&apos;s <code>optparse</code>.
Not clear. Some divergence. <code>parser.on(&quot;name&quot;, ...)</code> API is weird.</p>
</li>
<li>
<p><code>argparse</code> Dep on underscore. No thanks just for option processing.
<code>find lib | wc -l</code> -&gt; <code>26</code>. Overkill.
Argparse is a bit different anyway. Not sure I want that.</p>
</li>
<li>
<p><code>posix-getopt</code> No type validation. Though that isn&apos;t a killer. AFAIK can&apos;t
have a long opt without a short alias. I.e. no <code>getopt_long</code> semantics.
Also, no whizbang features like generated help output.</p>
</li>
<li>
<p><a href="https://github.com/visionmedia/commander.js" target="_blank" rel="noopener">&quot;commander.js&quot;</a>: I wrote
<a href="http://trentm.com/2014/01/a-critique-of-commander-for-nodejs.html" target="_blank" rel="noopener">a critique</a>
a while back. It seems fine, but last I checked had
<a href="https://github.com/visionmedia/commander.js/pull/121" target="_blank" rel="noopener">an outstanding bug</a>
that would prevent me from using it.</p>
</li>
</ul>
<h1>License</h1>
<p>MIT. See LICENSE.txt.</p>
</body></html></div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../assets/js/index.js"></script>
  </body>
</html>
