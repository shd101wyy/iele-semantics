<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="IELE Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../assets/img/favicon.ico" />

<title>IELE Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/iele-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../../Design">Design</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1>API Documentation</h1>
<p><em>Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.</em></p>
<h2><code>parser</code> function</h2>
<p>This is the module&apos;s main entry point.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;postcss-selector-parser&apos;</span>);
</code></pre>
<h3><code>parser([transform], [options])</code></h3>
<p>Creates a new <code>processor</code> instance</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> processor = parser();
</code></pre>
<p>Or, with optional transform function</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> transform = <span class="hljs-function"><span class="hljs-params">selectors</span> =&gt;</span> {
    selectors.walkUniversals(<span class="hljs-function"><span class="hljs-params">selector</span> =&gt;</span> {
        selector.remove();
    });
};

<span class="hljs-keyword">const</span> processor = parser(transform)

<span class="hljs-comment">// Example</span>
<span class="hljs-keyword">const</span> result = processor.processSync(<span class="hljs-string">&apos;*.class&apos;</span>);
<span class="hljs-comment">// =&gt; .class</span>
</code></pre>
<p><a href="#processor">See processor documentation</a></p>
<p>Arguments:</p>
<ul>
<li><code>transform (function)</code>: Provide a function to work with the parsed AST.</li>
<li><code>options (object)</code>: Provide default options for all calls on the returned <code>Processor</code>.</li>
</ul>
<h3><code>parser.attribute([props])</code></h3>
<p>Creates a new attribute selector.</p>
<pre class="hljs"><code>parser.attribute({<span class="hljs-attr">attribute</span>: <span class="hljs-string">&apos;href&apos;</span>});
<span class="hljs-comment">// =&gt; [href]</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.className([props])</code></h3>
<p>Creates a new class selector.</p>
<pre class="hljs"><code>parser.className({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;button&apos;</span>});
<span class="hljs-comment">// =&gt; .button</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.combinator([props])</code></h3>
<p>Creates a new selector combinator.</p>
<pre class="hljs"><code>parser.combinator({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;+&apos;</span>});
<span class="hljs-comment">// =&gt; +</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<p>Notes:</p>
<ul>
<li><strong>Descendant Combinators</strong> The value of descendant combinators created by the
parser always just a single space (<code>&quot; &quot;</code>). For descendant selectors with no
comments, additional space is now stored in <code>node.spaces.before</code>. Depending
on the location of comments, additional spaces may be stored in
<code>node.raws.spaces.before</code>, <code>node.raws.spaces.after</code>, or <code>node.raws.value</code>.</li>
<li><strong>Named Combinators</strong> Although, nonstandard and unlikely to ever become a standard,
named combinators like <code>/deep/</code> and <code>/for/</code> are parsed as combinators. The
<code>node.value</code> is name after being unescaped and normalized as lowercase. The
original value for the combinator name is stored in <code>node.raws.value</code>.</li>
</ul>
<h3><code>parser.comment([props])</code></h3>
<p>Creates a new comment.</p>
<pre class="hljs"><code>parser.comment({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;/* Affirmative, Dave. I read you. */&apos;</span>});
<span class="hljs-comment">// =&gt; /* Affirmative, Dave. I read you. */</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.id([props])</code></h3>
<p>Creates a new id selector.</p>
<pre class="hljs"><code>parser.id({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;search&apos;</span>});
<span class="hljs-comment">// =&gt; #search</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.nesting([props])</code></h3>
<p>Creates a new nesting selector.</p>
<pre class="hljs"><code>parser.nesting();
<span class="hljs-comment">// =&gt; &amp;</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.pseudo([props])</code></h3>
<p>Creates a new pseudo selector.</p>
<pre class="hljs"><code>parser.pseudo({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;::before&apos;</span>});
<span class="hljs-comment">// =&gt; ::before</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.root([props])</code></h3>
<p>Creates a new root node.</p>
<pre class="hljs"><code>parser.root();
<span class="hljs-comment">// =&gt; (empty)</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.selector([props])</code></h3>
<p>Creates a new selector node.</p>
<pre class="hljs"><code>parser.selector();
<span class="hljs-comment">// =&gt; (empty)</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.string([props])</code></h3>
<p>Creates a new string node.</p>
<pre class="hljs"><code>parser.string();
<span class="hljs-comment">// =&gt; (empty)</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.tag([props])</code></h3>
<p>Creates a new tag selector.</p>
<pre class="hljs"><code>parser.tag({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;button&apos;</span>});
<span class="hljs-comment">// =&gt; button</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h3><code>parser.universal([props])</code></h3>
<p>Creates a new universal selector.</p>
<pre class="hljs"><code>parser.universal();
<span class="hljs-comment">// =&gt; *</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node&apos;s properties.</li>
</ul>
<h2>Node types</h2>
<h3><code>node.type</code></h3>
<p>A string representation of the selector type. It can be one of the following;
<code>attribute</code>, <code>class</code>, <code>combinator</code>, <code>comment</code>, <code>id</code>, <code>nesting</code>, <code>pseudo</code>,
<code>root</code>, <code>selector</code>, <code>string</code>, <code>tag</code>, or <code>universal</code>. Note that for convenience,
these constants are exposed on the main <code>parser</code> as uppercased keys. So for
example you can get <code>id</code> by querying <code>parser.ID</code>.</p>
<pre class="hljs"><code>parser.attribute({<span class="hljs-attr">attribute</span>: <span class="hljs-string">&apos;href&apos;</span>}).type;
<span class="hljs-comment">// =&gt; &apos;attribute&apos;</span>
</code></pre>
<h3><code>node.parent</code></h3>
<p>Returns the parent node.</p>
<pre class="hljs"><code>root.nodes[<span class="hljs-number">0</span>].parent === root;
</code></pre>
<h3><code>node.toString()</code>, <code>String(node)</code>, or <code>&apos;&apos; + node</code></h3>
<p>Returns a string representation of the node.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> id = parser.id({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;search&apos;</span>});
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(id));
<span class="hljs-comment">// =&gt; #search</span>
</code></pre>
<h3><code>node.next()</code> &amp; <code>node.prev()</code></h3>
<p>Returns the next/previous child of the parent node.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> next = id.next();
<span class="hljs-keyword">if</span> (next &amp;&amp; next.type !== <span class="hljs-string">&apos;combinator&apos;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&apos;Qualified IDs are not allowed!&apos;</span>);
}
</code></pre>
<h3><code>node.replaceWith(node)</code></h3>
<p>Replace a node with another.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> attr = selectors.first.first;
<span class="hljs-keyword">const</span> className = parser.className({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;test&apos;</span>});
attr.replaceWith(className);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to substitute the original with.</li>
</ul>
<h3><code>node.remove()</code></h3>
<p>Removes the node from its parent node.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">&apos;id&apos;</span>) {
    node.remove();
}
</code></pre>
<h3><code>node.clone()</code></h3>
<p>Returns a copy of a node, detached from any parent containers that the
original might have had.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> cloned = parser.id({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;search&apos;</span>});
<span class="hljs-built_in">String</span>(cloned);

<span class="hljs-comment">// =&gt; #search</span>
</code></pre>
<h3><code>node.isAtPosition(line, column)</code></h3>
<p>Return a <code>boolean</code> indicating whether this node includes the character at the
position of the given line and column. Returns <code>undefined</code> if the nodes lack
sufficient source metadata to determine the position.</p>
<p>Arguments:</p>
<ul>
<li><code>line</code>: 1-index based line number relative to the start of the selector.</li>
<li><code>column</code>: 1-index based column number relative to the start of the selector.</li>
</ul>
<h3><code>node.spaces</code></h3>
<p>Extra whitespaces around the node will be moved into <code>node.spaces.before</code> and
<code>node.spaces.after</code>. So for example, these spaces will be moved as they have
no semantic meaning:</p>
<pre class="hljs"><code>      <span class="hljs-selector-tag">h1</span>     ,     <span class="hljs-selector-tag">h2</span>   {}
</code></pre>
<p>For descendent selectors, the value is always a single space.</p>
<pre class="hljs"><code><span class="hljs-selector-tag">h1</span>        <span class="hljs-selector-tag">h2</span> {}
</code></pre>
<p>Additional whitespace is found in either the <code>node.spaces.before</code> and <code>node.spaces.after</code> depending on the presence of comments or other whitespace characters. If the actual whitespace does not start or end with a single space, the node&apos;s raw value is set to the actual space(s) found in the source.</p>
<h3><code>node.source</code></h3>
<p>An object describing the node&apos;s start/end, line/column source position.</p>
<p>Within the following CSS, the <code>.bar</code> class node ...</p>
<pre class="hljs"><code><span class="hljs-selector-class">.foo</span>,
  <span class="hljs-selector-class">.bar</span> {}
</code></pre>
<p>... will contain the following <code>source</code> object.</p>
<pre class="hljs"><code>source: {
    <span class="hljs-attr">start</span>: {
        <span class="hljs-attr">line</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">3</span>
    },
    <span class="hljs-attr">end</span>: {
        <span class="hljs-attr">line</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">column</span>: <span class="hljs-number">6</span>
    }
}
</code></pre>
<h3><code>node.sourceIndex</code></h3>
<p>The zero-based index of the node within the original source string.</p>
<p>Within the following CSS, the <code>.baz</code> class node will have a <code>sourceIndex</code> of <code>12</code>.</p>
<pre class="hljs"><code><span class="hljs-selector-class">.foo</span>, <span class="hljs-selector-class">.bar</span>, <span class="hljs-selector-class">.baz</span> {}
</code></pre>
<h2>Container types</h2>
<p>The <code>root</code>, <code>selector</code>, and <code>pseudo</code> nodes have some helper methods for working
with their children.</p>
<h3><code>container.nodes</code></h3>
<p>An array of the container&apos;s children.</p>
<pre class="hljs"><code><span class="hljs-comment">// Input: h1 h2</span>
selectors.at(<span class="hljs-number">0</span>).nodes.length   <span class="hljs-comment">// =&gt; 3</span>
selectors.at(<span class="hljs-number">0</span>).nodes[<span class="hljs-number">0</span>].value <span class="hljs-comment">// =&gt; &apos;h1&apos;</span>
selectors.at(<span class="hljs-number">0</span>).nodes[<span class="hljs-number">1</span>].value <span class="hljs-comment">// =&gt; &apos; &apos;</span>
</code></pre>
<h3><code>container.first</code> &amp; <code>container.last</code></h3>
<p>The first/last child of the container.</p>
<pre class="hljs"><code>selector.first === selector.nodes[<span class="hljs-number">0</span>];
selector.last === selector.nodes[selector.nodes.length - <span class="hljs-number">1</span>];
</code></pre>
<h3><code>container.at(index)</code></h3>
<p>Returns the node at position <code>index</code>.</p>
<pre class="hljs"><code>selector.at(<span class="hljs-number">0</span>) === selector.first;
selector.at(<span class="hljs-number">0</span>) === selector.nodes[<span class="hljs-number">0</span>];
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>index</code>: The index of the node to return.</li>
</ul>
<h3><code>container.atPosition(line, column)</code></h3>
<p>Returns the node at the source position <code>index</code>.</p>
<pre class="hljs"><code>selector.at(<span class="hljs-number">0</span>) === selector.first;
selector.at(<span class="hljs-number">0</span>) === selector.nodes[<span class="hljs-number">0</span>];
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>index</code>: The index of the node to return.</li>
</ul>
<h3><code>container.index(node)</code></h3>
<p>Return the index of the node within its container.</p>
<pre class="hljs"><code>selector.index(selector.nodes[<span class="hljs-number">2</span>]) <span class="hljs-comment">// =&gt; 2</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: A node within the current container.</li>
</ul>
<h3><code>container.length</code></h3>
<p>Proxy to the length of the container&apos;s nodes.</p>
<pre class="hljs"><code>container.length === container.nodes.length
</code></pre>
<h3><code>container</code> Array iterators</h3>
<p>The container class provides proxies to certain Array methods; these are:</p>
<ul>
<li><code>container.map === container.nodes.map</code></li>
<li><code>container.reduce === container.nodes.reduce</code></li>
<li><code>container.every === container.nodes.every</code></li>
<li><code>container.some === container.nodes.some</code></li>
<li><code>container.filter === container.nodes.filter</code></li>
<li><code>container.sort === container.nodes.sort</code></li>
</ul>
<p>Note that these methods only work on a container&apos;s immediate children; recursive
iteration is provided by <code>container.walk</code>.</p>
<h3><code>container.each(callback)</code></h3>
<p>Iterate the container&apos;s immediate children, calling <code>callback</code> for each child.
You may return <code>false</code> within the callback to break the iteration.</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> className;
selectors.each(<span class="hljs-function">(<span class="hljs-params">selector, index</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (selector.type === <span class="hljs-string">&apos;class&apos;</span>) {
        className = selector.value;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
});
</code></pre>
<p>Note that unlike <code>Array#forEach()</code>, this iterator is safe to use whilst adding
or removing nodes from the container.</p>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>
<h3><code>container.walk(callback)</code></h3>
<p>Like <code>container#each</code>, but will also iterate child nodes as long as they are
<code>container</code> types.</p>
<pre class="hljs"><code>selectors.walk(<span class="hljs-function">(<span class="hljs-params">selector, index</span>) =&gt;</span> {
    <span class="hljs-comment">// all nodes</span>
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
and <code>index</code> arguments.</li>
</ul>
<p>This iterator is safe to use whilst mutating <code>container.nodes</code>,
like <code>container#each</code>.</p>
<h3><code>container.walk</code> proxies</h3>
<p>The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:</p>
<ul>
<li><code>container.walkAttributes</code></li>
<li><code>container.walkClasses</code></li>
<li><code>container.walkCombinators</code></li>
<li><code>container.walkComments</code></li>
<li><code>container.walkIds</code></li>
<li><code>container.walkNesting</code></li>
<li><code>container.walkPseudos</code></li>
<li><code>container.walkTags</code></li>
<li><code>container.walkUniversals</code></li>
</ul>
<h3><code>container.split(callback)</code></h3>
<p>This method allows you to split a group of nodes by returning <code>true</code> from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.</p>
<pre class="hljs"><code><span class="hljs-comment">// (input) =&gt; h1 h2&gt;&gt;h3</span>
<span class="hljs-keyword">const</span> list = selectors.first.split(<span class="hljs-function"><span class="hljs-params">selector</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> selector.type === <span class="hljs-string">&apos;combinator&apos;</span>;
});

<span class="hljs-comment">// (node values) =&gt; [[&apos;h1&apos;, &apos; &apos;], [&apos;h2&apos;, &apos;&gt;&gt;&apos;], [&apos;h3&apos;]]</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code>
as an argument.</li>
</ul>
<h3><code>container.prepend(node)</code> &amp; <code>container.append(node)</code></h3>
<p>Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> id = parser.id({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;search&apos;</span>});
selector.append(id);
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to add.</li>
</ul>
<h3><code>container.insertBefore(old, new)</code> &amp; <code>container.insertAfter(old, new)</code></h3>
<p>Add a node before or after an existing node in a container:</p>
<pre class="hljs"><code>selectors.walk(<span class="hljs-function"><span class="hljs-params">selector</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (selector.type !== <span class="hljs-string">&apos;class&apos;</span>) {
        <span class="hljs-keyword">const</span> className = parser.className({<span class="hljs-attr">value</span>: <span class="hljs-string">&apos;theme-name&apos;</span>});
        selector.parent.insertAfter(selector, className);
    }
});
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>old</code>: The existing node in the container.</li>
<li><code>new</code>: The new node to add before/after the existing node.</li>
</ul>
<h3><code>container.removeChild(node)</code></h3>
<p>Remove the node from the container. Note that you can also use
<code>node.remove()</code> if you would like to remove just a single node.</p>
<pre class="hljs"><code>selector.length <span class="hljs-comment">// =&gt; 2</span>
selector.remove(id)
selector.length <span class="hljs-comment">// =&gt; 1;</span>
id.parent       <span class="hljs-comment">// undefined</span>
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>node</code>: The node to remove.</li>
</ul>
<h3><code>container.removeAll()</code> or <code>container.empty()</code></h3>
<p>Remove all children from the container.</p>
<pre class="hljs"><code>selector.removeAll();
selector.length <span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<h2>Root nodes</h2>
<p>A root node represents a comma separated list of selectors. Indeed, all
a root&apos;s <code>toString()</code> method does is join its selector children with a &apos;,&apos;.
Other than this, it has no special functionality and acts like a container.</p>
<h3><code>root.trailingComma</code></h3>
<p>This will be set to <code>true</code> if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.</p>
<h2>Selector nodes</h2>
<p>A selector node represents a single complex selector. For example, this
selector string <code>h1 h2 h3, [href] &gt; p</code>, is represented as two selector nodes.
It has no special functionality of its own.</p>
<h2>Pseudo nodes</h2>
<p>A pseudo selector extends a container node; if it has any parameters of its
own (such as <code>h1:not(h2, h3)</code>), they will be its children. Note that the pseudo
<code>value</code> will always contain the colons preceding the pseudo identifier. This
is so that both <code>:before</code> and <code>::before</code> are properly represented in the AST.</p>
<h2>Attribute nodes</h2>
<h3><code>attribute.quoted</code></h3>
<p>Returns <code>true</code> if the attribute&apos;s value is wrapped in quotation marks, false if it is not.
Remains <code>undefined</code> if there is no attribute value.</p>
<pre class="hljs"><code><span class="hljs-selector-attr">[href=foo]</span> <span class="hljs-comment">/* false */</span>
<span class="hljs-selector-attr">[href=<span class="hljs-string">&apos;foo&apos;</span>]</span> <span class="hljs-comment">/* true */</span>
<span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;foo&quot;</span>]</span> <span class="hljs-comment">/* true */</span>
<span class="hljs-selector-attr">[href]</span> <span class="hljs-comment">/* undefined */</span>
</code></pre>
<h3><code>attribute.qualifiedAttribute</code></h3>
<p>Returns the attribute name qualified with the namespace if one is given.</p>
<h3><code>attribute.offsetOf(part)</code></h3>
<p>Returns the offset of the attribute part specified relative to the
start of the node of the output string. This is useful in raising
error messages about a specific part of the attribute, especially
in combination with <code>attribute.sourceIndex</code>.</p>
<p>Returns <code>-1</code> if the name is invalid or the value doesn&apos;t exist in this
attribute.</p>
<p>The legal values for <code>part</code> are:</p>
<ul>
<li><code>&quot;ns&quot;</code> - alias for &quot;namespace&quot;</li>
<li><code>&quot;namespace&quot;</code> - the namespace if it exists.</li>
<li><code>&quot;attribute&quot;</code> - the attribute name</li>
<li><code>&quot;attributeNS&quot;</code> - the start of the attribute or its namespace</li>
<li><code>&quot;operator&quot;</code> - the match operator of the attribute</li>
<li><code>&quot;value&quot;</code> - The value (string or identifier)</li>
<li><code>&quot;insensitive&quot;</code> - the case insensitivity flag</li>
</ul>
<h3><code>attribute.raws.unquoted</code></h3>
<p>Returns the unquoted content of the attribute&apos;s value.
Remains <code>undefined</code> if there is no attribute value.</p>
<pre class="hljs"><code><span class="hljs-selector-attr">[href=foo]</span> <span class="hljs-comment">/* foo */</span>
<span class="hljs-selector-attr">[href=<span class="hljs-string">&apos;foo&apos;</span>]</span> <span class="hljs-comment">/* foo */</span>
<span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;foo&quot;</span>]</span> <span class="hljs-comment">/* foo */</span>
<span class="hljs-selector-attr">[href]</span> <span class="hljs-comment">/* undefined */</span>
</code></pre>
<h3><code>attribute.spaces</code></h3>
<p>Like <code>node.spaces</code> with the <code>before</code> and <code>after</code> values containing the spaces
around the element, the parts of the attribute can also have spaces before
and after them. The for each of <code>attribute</code>, <code>operator</code>, <code>value</code> and
<code>insensitive</code> there is corresponding property of the same nam in
<code>node.spaces</code> that has an optional <code>before</code> or <code>after</code> string containing only
whitespace.</p>
<p>Note that corresponding values in <code>attributes.raws.spaces</code> contain values
including any comments. If set, these values will override the
<code>attribute.spaces</code> value. Take care to remove them if changing
<code>attribute.spaces</code>.</p>
<h3><code>attribute.raws</code></h3>
<p>The raws object stores comments and other information necessary to re-render
the node exactly as it was in the source.</p>
<p>If a comment is embedded within the identifiers for the <code>namespace</code>, <code>attribute</code>
or <code>value</code> then a property is placed in the raws for that value containing the full source of the propery including comments.</p>
<p>If a comment is embedded within the space between parts of the attribute
then the raw for that space is set accordingly.</p>
<p>Setting an attribute&apos;s property <code>raws</code> value to be deleted.</p>
<p>For now, changing the spaces required also updating or removing any of the
raws values that override them.</p>
<p>Example: <code>[ /*before*/ href /* after-attr */ = /* after-operator */ te/*inside-value*/st/* wow */ /*omg*/i/*bbq*/ /*whodoesthis*/]</code> would parse as:</p>
<pre class="hljs"><code>{
  <span class="hljs-attr">attribute</span>: <span class="hljs-string">&quot;href&quot;</span>,
  <span class="hljs-attr">operatator</span>: <span class="hljs-string">&quot;=&quot;</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;test&quot;</span>,
  <span class="hljs-attr">spaces</span>: {
    <span class="hljs-attr">before</span>: <span class="hljs-string">&apos;&apos;</span>,
    <span class="hljs-attr">after</span>: <span class="hljs-string">&apos;&apos;</span>,
    <span class="hljs-attr">attribute</span>: { <span class="hljs-attr">before</span>: <span class="hljs-string">&apos;  &apos;</span>, <span class="hljs-attr">after</span>: <span class="hljs-string">&apos;  &apos;</span> },
    <span class="hljs-attr">operator</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos;  &apos;</span> },
    <span class="hljs-attr">value</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos; &apos;</span> },
    <span class="hljs-attr">insensitive</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos; &apos;</span> }
  },
  <span class="hljs-attr">raws</span>: {
    <span class="hljs-attr">spaces</span>: {
      <span class="hljs-attr">attribute</span>: { <span class="hljs-attr">before</span>: <span class="hljs-string">&apos; /*before*/ &apos;</span>, <span class="hljs-attr">after</span>: <span class="hljs-string">&apos; /* after-attr */ &apos;</span> },
      <span class="hljs-attr">operator</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos; /* after-operator */ &apos;</span> },
      <span class="hljs-attr">value</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos;/* wow */ /*omg*/&apos;</span> },
      <span class="hljs-attr">insensitive</span>: { <span class="hljs-attr">after</span>: <span class="hljs-string">&apos;/*bbq*/ /*whodoesthis*/&apos;</span> }
    },
    <span class="hljs-attr">unquoted</span>: <span class="hljs-string">&apos;test&apos;</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">&apos;te/*inside-value*/st&apos;</span>
  }
}
</code></pre>
<h2><code>Processor</code></h2>
<h3><code>ProcessorOptions</code></h3>
<ul>
<li><code>lossless</code> - When <code>true</code>, whitespace is preserved. Defaults to <code>true</code>.</li>
<li><code>updateSelector</code> - When <code>true</code>, if any processor methods are passed a postcss
<code>Rule</code> node instead of a string, then that Rule&apos;s selector is updated
with the results of the processing. Defaults to <code>true</code>.</li>
</ul>
<h3><code>process|processSync(selectors, [options])</code></h3>
<p>Processes the <code>selectors</code>, returning a string from the result of processing.</p>
<p>Note: when the <code>updateSelector</code> option is set, the rule&apos;s selector
will be updated with the resulting string.</p>
<p><strong>Example:</strong></p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-selector-parser&quot;</span>);
<span class="hljs-keyword">const</span> processor = parser();

<span class="hljs-keyword">let</span> result = processor.processSync(<span class="hljs-string">&apos; .class&apos;</span>);
<span class="hljs-built_in">console</span>.log(result);
<span class="hljs-comment">// =&gt;  .class</span>

<span class="hljs-comment">// Asynchronous operation</span>
<span class="hljs-keyword">let</span> promise = processor.process(<span class="hljs-string">&apos; .class&apos;</span>).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result)
    <span class="hljs-comment">// =&gt; .class</span>
});

<span class="hljs-comment">// To have the parser normalize whitespace values, utilize the options</span>
result = processor.processSync(<span class="hljs-string">&apos;  .class  &apos;</span>, {<span class="hljs-attr">lossless</span>: <span class="hljs-literal">false</span>});
<span class="hljs-built_in">console</span>.log(result);
<span class="hljs-comment">// =&gt; .class</span>

<span class="hljs-comment">// For better syntax errors, pass a PostCSS Rule node.</span>
<span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;postcss&apos;</span>);
rule = postcss.rule({<span class="hljs-attr">selector</span>: <span class="hljs-string">&apos; #foo    &gt; a,  .class  &apos;</span>});
processor.process(rule, {<span class="hljs-attr">lossless</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">updateSelector</span>: <span class="hljs-literal">true</span>}).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(result);
    <span class="hljs-comment">// =&gt; #foo&gt;a,.class</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rule:&quot;</span>, rule.selector);
    <span class="hljs-comment">// =&gt; rule: #foo&gt;a,.class</span>
})
</code></pre>
<p>Arguments:</p>
<ul>
<li><code>selectors (string|postcss.Rule)</code>: Either a selector string or a PostCSS Rule
node.</li>
<li><code>[options] (object)</code>: Process options</li>
</ul>
<h3><code>ast|astSync(selectors, [options])</code></h3>
<p>Like <code>process()</code> and <code>processSync()</code> but after
processing the <code>selectors</code> these methods return the <code>Root</code> node of the result
instead of a string.</p>
<p>Note: when the <code>updateSelector</code> option is set, the rule&apos;s selector
will be updated with the resulting string.</p>
<h3><code>transform|transformSync(selectors, [options])</code></h3>
<p>Like <code>process()</code> and <code>processSync()</code> but after
processing the <code>selectors</code> these methods return the value returned by the
processor callback.</p>
<p>Note: when the <code>updateSelector</code> option is set, the rule&apos;s selector
will be updated with the resulting string.</p>
<h3>Error Handling Within Selector Processors</h3>
<p>The root node passed to the selector processor callback
has a method <code>error(message, options)</code> that returns an
error object. This method should always be used to raise
errors relating to the syntax of selectors. The options
to this method are passed to postcss&apos;s error constructor
(<a href="http://api.postcss.org/Container.html#error" target="_blank" rel="noopener">documentation</a>).</p>
<h4>Async Error Example</h4>
<pre class="hljs"><code><span class="hljs-keyword">let</span> processor = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        root.walkClasses(<span class="hljs-function">(<span class="hljs-params">classNode</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(.*)[-_]/</span>.test(classNode.value)) {
                <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;classes may not have underscores or dashes in them&quot;</span>;
                reject(root.error(msg, {
                    <span class="hljs-attr">index</span>: classNode.sourceIndex + <span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1.</span>length + <span class="hljs-number">1</span>,
                    <span class="hljs-attr">word</span>: classNode.value
                }));
            }
        });
        resolve();
    });
};

<span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss&quot;</span>);
<span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-selector-parser&quot;</span>);
<span class="hljs-keyword">const</span> selectorProcessor = parser(processor);
<span class="hljs-keyword">const</span> plugin = postcss.plugin(<span class="hljs-string">&apos;classValidator&apos;</span>, <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> promises = [];
        root.walkRules(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> {
            promises.push(selectorProcessor.process(rule));
        });
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(promises);
    };
});
postcss(plugin()).process(<span class="hljs-string">`
.foo-bar {
  color: red;
}
`</span>.trim(), {<span class="hljs-attr">from</span>: <span class="hljs-string">&apos;test.css&apos;</span>}).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(e.toString()));

<span class="hljs-comment">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &gt; 1 | .foo-bar {</span>
<span class="hljs-comment">//     |     ^</span>
<span class="hljs-comment">//   2 |   color: red;</span>
<span class="hljs-comment">//   3 | }</span>
</code></pre>
<h4>Synchronous Error Example</h4>
<pre class="hljs"><code><span class="hljs-keyword">let</span> processor = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
    root.walkClasses(<span class="hljs-function">(<span class="hljs-params">classNode</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/.*[-_]/</span>.test(classNode.value)) {
            <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;classes may not have underscores or dashes in them&quot;</span>;
            <span class="hljs-keyword">throw</span> root.error(msg, {
                <span class="hljs-attr">index</span>: classNode.sourceIndex,
                <span class="hljs-attr">word</span>: classNode.value
            });
        }
    });
};

<span class="hljs-keyword">const</span> postcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss&quot;</span>);
<span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;postcss-selector-parser&quot;</span>);
<span class="hljs-keyword">const</span> selectorProcessor = parser(processor);
<span class="hljs-keyword">const</span> plugin = postcss.plugin(<span class="hljs-string">&apos;classValidator&apos;</span>, <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> {
        root.walkRules(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> {
            selectorProcessor.processSync(rule);
        });
    };
});
postcss(plugin()).process(<span class="hljs-string">`
.foo-bar {
  color: red;
}
`</span>.trim(), {<span class="hljs-attr">from</span>: <span class="hljs-string">&apos;test.css&apos;</span>}).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">console</span>.error(e.toString()));

<span class="hljs-comment">// CssSyntaxError: classValidator: ./test.css:1:5: classes may not have underscores or dashes in them</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// &gt; 1 | .foo-bar {</span>
<span class="hljs-comment">//     |     ^</span>
<span class="hljs-comment">//   2 |   color: red;</span>
<span class="hljs-comment">//   3 | }</span>
</code></pre>
</body></html></div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../assets/js/index.js"></script>
  </body>
</html>
