<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="IELE Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../../../assets/img/favicon.ico" />

<title>IELE Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../../../assets/img/k-logo.png"
      alt="K"
      style="height: 48px"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/iele-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../../../Design">Design</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1>AsyncWorker</h1>
<p><code>Napi::AsyncWorker</code> is an abstract class that you can subclass to remove many of
the tedious tasks of moving data between the event loop and worker threads. This
class internally handles all the details of creating and executing an asynchronous
operation.</p>
<p>Once created, execution is requested by calling <code>Napi::AsyncWorker::Queue</code>. When
a thread is available for execution the <code>Napi::AsyncWorker::Execute</code> method will
be invoked.  Once <code>Napi::AsyncWorker::Execute</code> completes either
<code>Napi::AsyncWorker::OnOK</code> or <code>Napi::AsyncWorker::OnError</code> will be invoked.  Once
the <code>Napi::AsyncWorker::OnOK</code> or <code>Napi::AsyncWorker::OnError</code> methods are
complete the <code>Napi::AsyncWorker</code> instance is destructed.</p>
<p>For the most basic use, only the <code>Napi::AsyncWorker::Execute</code> method must be
implemented in a subclass.</p>
<h2>Methods</h2>
<h3>Env</h3>
<p>Requests the environment in which the async worker has been initially created.</p>
<pre class="hljs"><code>Napi::Env Napi::AsyncWorker::Env() <span class="hljs-keyword">const</span>;
</code></pre>
<p>Returns the environment in which the async worker has been created.</p>
<h3>Queue</h3>
<p>Requests that the work be queued for execution.</p>
<pre class="hljs"><code><span class="hljs-keyword">void</span> Napi::AsyncWorker::Queue();
</code></pre>
<h3>Cancel</h3>
<p>Cancels queued work if it has not yet been started. If it has already started
executing, it cannot be cancelled.  If cancelled successfully neither
<code>OnOK</code> nor <code>OnError</code> will be called.</p>
<pre class="hljs"><code><span class="hljs-keyword">void</span> Napi::AsyncWorker::Cancel();
</code></pre>
<h3>Receiver</h3>
<pre class="hljs"><code>Napi::ObjectReference&amp; Napi::AsyncWorker::Receiver();
</code></pre>
<p>Returns the persistent object reference of the receiver object set when the async
worker was created.</p>
<h3>Callback</h3>
<pre class="hljs"><code>Napi::FunctionReference&amp; Napi::AsyncWorker::Callback();
</code></pre>
<p>Returns the persistent function reference of the callback set when the async
worker was created. The returned function reference will receive the results of
the computation that happened in the <code>Napi::AsyncWorker::Execute</code> method, unless
the default implementation of <code>Napi::AsyncWorker::OnOK</code> or
<code>Napi::AsyncWorker::OnError</code> is overridden.</p>
<h3>SuppressDestruct</h3>
<pre class="hljs"><code><span class="hljs-keyword">void</span> Napi::AsyncWorker::SuppressDestruct();
</code></pre>
<p>Prevents the destruction of the <code>Napi::AsyncWorker</code> instance upon completion of
the <code>Napi::AsyncWorker::OnOK</code> callback.</p>
<h3>SetError</h3>
<p>Sets the error message for the error that happened during the execution. Setting
an error message will cause the <code>Napi::AsyncWorker::OnError</code> method to be
invoked instead of <code>Napi::AsyncWorker::OnOK</code> once the
<code>Napi::AsyncWorker::Execute</code> method completes.</p>
<pre class="hljs"><code><span class="hljs-keyword">void</span> Napi::AsyncWorker::SetError(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; error);
</code></pre>
<ul>
<li><code>[in] error</code>: The reference to the string that represent the message of the error.</li>
</ul>
<h3>Execute</h3>
<p>This method is used to execute some tasks out of the <strong>event loop</strong> on a libuv
worker thread. Subclasses must implement this method and the method is run on
a thread other than that running the main event loop.  As the method is not
running on the main event loop, it must avoid calling any methods from node-addon-api
or running any code that might invoke JavaScript. Instead, once this method is
complete any interaction through node-addon-api with JavaScript should be implemented
in the <code>Napi::AsyncWorker::OnOK</code> method which runs on the main thread and is
invoked when the <code>Napi::AsyncWorker::Execute</code> method completes.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> Napi::AsyncWorker::Execute() = <span class="hljs-number">0</span>;
</code></pre>
<h3>OnOK</h3>
<p>This method is invoked when the computation in the <code>Execute</code> method ends.
The default implementation runs the Callback optionally provided when the AsyncWorker class
was created. The callback will by default receive no arguments. To provide arguments,
override the <code>GetResult()</code> method.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> Napi::AsyncWorker::OnOK();
</code></pre>
<h3>GetResult</h3>
<p>This method returns the arguments passed to the Callback invoked by the default
<code>OnOK()</code> implementation. The default implementation returns an empty vector,
providing no arguments to the Callback.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;napi_value&gt; Napi::AsyncWorker::GetResult(Napi::Env env);
</code></pre>
<h3>OnError</h3>
<p>This method is invoked after <code>Napi::AsyncWorker::Execute</code> completes if an error
occurs while <code>Napi::AsyncWorker::Execute</code> is running and C++ exceptions are
enabled or if an error was set through a call to <code>Napi::AsyncWorker::SetError</code>.
The default implementation calls the callback provided when the <code>Napi::AsyncWorker</code>
class was created, passing in the error as the first parameter.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> Napi::AsyncWorker::OnError(<span class="hljs-keyword">const</span> Napi::Error&amp; e);
</code></pre>
<h3>Destroy</h3>
<p>This method is invoked when the instance must be deallocated. If
<code>SuppressDestruct()</code> was not called then this method will be called after either
<code>OnError()</code> or <code>OnOK()</code> complete. The default implementation of this method
causes the instance to delete itself using the <code>delete</code> operator. The method is
provided so as to ensure that instances allocated by means other than the <code>new</code>
operator can be deallocated upon work completion.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> Napi::AsyncWorker::Destroy();
</code></pre>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Function&amp; callback)</span></span>;
</code></pre>
<ul>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by calling
<code>Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)</span></span>;
</code></pre>
<ul>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
<li><code>[in] resource_name</code>: Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWork::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name, <span class="hljs-keyword">const</span> Napi::Object&amp; resource)</span></span>;
</code></pre>
<ul>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
<li><code>[in] resource_name</code>:  Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
<li><code>[in] resource</code>: Object associated with the asynchronous operation that
will be passed to possible async_hooks.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWork::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Object&amp; receiver, <span class="hljs-keyword">const</span> Napi::Function&amp; callback)</span></span>;
</code></pre>
<ul>
<li><code>[in] receiver</code>: The <code>this</code> object passed to the called function.</li>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWork::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Object&amp; receiver, <span class="hljs-keyword">const</span> Napi::Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)</span></span>;
</code></pre>
<ul>
<li><code>[in] receiver</code>: The <code>this</code> object passed to the called function.</li>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
<li><code>[in] resource_name</code>:  Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
</ul>
<p>Returns a <code>Napi::AsyncWork</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWork::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Napi::Object&amp; receiver, <span class="hljs-keyword">const</span> Napi::Function&amp; callback, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name, <span class="hljs-keyword">const</span> Napi::Object&amp; resource)</span></span>;
</code></pre>
<ul>
<li><code>[in] receiver</code>: The <code>this</code> object passed to the called function.</li>
<li><code>[in] callback</code>: The function which will be called when an asynchronous
operations ends. The given function is called from the main event loop thread.</li>
<li><code>[in] resource_name</code>:  Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
<li><code>[in] resource</code>: Object associated with the asynchronous operation that
will be passed to possible async_hooks.</li>
</ul>
<p>Returns a <code>Napi::AsyncWork</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWork::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(Napi::Env env)</span></span>;
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::AsyncWorker</code>.</li>
</ul>
<p>Returns an <code>Napi::AsyncWorker</code> instance which can later be queued for execution by calling
<code>Napi::AsyncWorker::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(Napi::Env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name)</span></span>;
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::AsyncWorker</code>.</li>
<li><code>[in] resource_name</code>: Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWorker::Queue</code>.</p>
<h3>Constructor</h3>
<p>Creates a new <code>Napi::AsyncWorker</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Napi::AsyncWorker</span><span class="hljs-params">(Napi::Env env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* resource_name, <span class="hljs-keyword">const</span> Napi::Object&amp; resource)</span></span>;
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::AsyncWorker</code>.</li>
<li><code>[in] resource_name</code>:  Null-terminated strings that represents the
identifier for the kind of resource that is being provided for diagnostic
information exposed by the async_hooks API.</li>
<li><code>[in] resource</code>: Object associated with the asynchronous operation that
will be passed to possible async_hooks.</li>
</ul>
<p>Returns a <code>Napi::AsyncWorker</code> instance which can later be queued for execution by
calling <code>Napi::AsyncWorker::Queue</code>.</p>
<h3>Destructor</h3>
<p>Deletes the created work object that is used to execute logic asynchronously.</p>
<pre class="hljs"><code><span class="hljs-keyword">virtual</span> Napi::AsyncWorker::~AsyncWorker();
</code></pre>
<h2>Operator</h2>
<pre class="hljs"><code>Napi::<span class="hljs-function">AsyncWorker::<span class="hljs-keyword">operator</span> <span class="hljs-title">napi_async_work</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
</code></pre>
<p>Returns the N-API napi_async_work wrapped by the <code>Napi::AsyncWorker</code> object. This
can be used to mix usage of the C N-API and node-addon-api.</p>
<h2>Example</h2>
<p>The first step to use the <code>Napi::AsyncWorker</code> class is to create a new class that
inherits from it and implement the <code>Napi::AsyncWorker::Execute</code> abstract method.
Typically input to your worker will be saved within class&apos; fields generally
passed in through its constructor.</p>
<p>When the <code>Napi::AsyncWorker::Execute</code> method completes without errors the
<code>Napi::AsyncWorker::OnOK</code> function callback will be invoked. In this function the
results of the computation will be reassembled and returned back to the initial
JavaScript context.</p>
<p><code>Napi::AsyncWorker</code> ensures that all the code in the <code>Napi::AsyncWorker::Execute</code>
function runs in the background out of the <strong>event loop</strong> thread and at the end
the <code>Napi::AsyncWorker::OnOK</code> or <code>Napi::AsyncWorker::OnError</code> function will be
called and are executed as part of the event loop.</p>
<p>The code below show a basic example of <code>Napi::AsyncWorker</code> the implementation:</p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;napi.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span>

use <span class="hljs-keyword">namespace</span> Napi;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoWorker</span> :</span> <span class="hljs-keyword">public</span> AsyncWorker {
    <span class="hljs-keyword">public</span>:
        EchoWorker(Function&amp; callback, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; echo)
        : AsyncWorker(callback), echo(echo) {}

        ~EchoWorker() {}
    <span class="hljs-comment">// This code will be executed on the worker thread</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Need to simulate cpu heavy task</span>
        <span class="hljs-built_in">std</span>::this_thread::sleep_for(<span class="hljs-built_in">std</span>::chrono::seconds(<span class="hljs-number">1</span>));
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnOK</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">HandleScope <span class="hljs-title">scope</span><span class="hljs-params">(Env())</span></span>;
        Callback().Call({Env().Null(), String::New(Env(), echo)});
    }

    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> echo;
};
</code></pre>
<p>The <code>EchoWorker</code>&apos;s contructor calls the base class&apos; constructor to pass in the
callback that the <code>Napi::AsyncWorker</code> base class will store persistently. When
the work on the <code>Napi::AsyncWorker::Execute</code> method is done the
<code>Napi::AsyncWorker::OnOk</code> method is called and the results return back to
JavaScript invoking the stored callback with its associated environment.</p>
<p>The following code shows an example on how to create and use an <code>Napi::AsyncWorker</code></p>
<pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;napi.h&gt;</span></span>

<span class="hljs-comment">// Include EchoWorker class</span>
<span class="hljs-comment">// ..</span>

use <span class="hljs-keyword">namespace</span> Napi;

<span class="hljs-function">Value <span class="hljs-title">Echo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CallbackInfo&amp; info)</span> </span>{
    <span class="hljs-comment">// You need to check the input data here</span>
    Function cb = info[<span class="hljs-number">1</span>].As&lt;Function&gt;();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> in = info[<span class="hljs-number">0</span>].As&lt;String&gt;();
    EchoWorker* wk = <span class="hljs-keyword">new</span> EchoWorker(cb, in);
    wk-&gt;Queue();
    <span class="hljs-keyword">return</span> info.Env().Undefined();
</code></pre>
<p>Using the implementation of a <code>Napi::AsyncWorker</code> is straight forward. You only
need to create a new instance and pass to its constructor the callback you want to
execute when your asynchronous task ends and other data you need for your
computation. Once created the only other action you have to do is to call the
<code>Napi::AsyncWorker::Queue</code> method that will queue the created worker for execution.</p>
</body></html></div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../../assets/js/index.js"></script>
  </body>
</html>
