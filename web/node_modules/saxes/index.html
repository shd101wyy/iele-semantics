<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="Design and implement your programming language and software analysis tools with mathematical rigor."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="IELE Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<link rel="icon" type="image/png" href="../../../assets/img/favicon.ico" />

<title>IELE Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../index.html">
    <img
      class="logo-dark"
      srcset="../../../assets/img/iele-logo.png"
      alt="K"
      style="height: 48px"
    />
    Semantic Framework
  </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/iele-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../downloads"
    >Download</a
  >
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../Design">Design</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1>saxes</h1>
<p>A sax-style non-validating parser for XML.</p>
<p>Saxes is a fork of <a href="https://github.com/isaacs/sax-js" target="_blank" rel="noopener">sax</a> 1.2.4. All mentions
of sax in this project&apos;s documentation are references to sax 1.2.4.</p>
<p>Designed with <a href="http://nodejs.org/" target="_blank" rel="noopener">node</a> in mind, but should work fine in the
browser or other CommonJS implementations.</p>
<p>Saxes does not support Node versions older than 8.</p>
<h2>Notable Differences from Sax.</h2>
<ul>
<li>
<p>Saxes aims to be much stricter than sax with regards to XML
well-formedness. Sax, even in its so-called &quot;strict mode&quot;, is not strict. It
silently accepts structures that are not well-formed XML. Projects that need
better compliance with well-formedness constraints cannot use sax as-is.
Saxes aims for conformance with <a href="https://www.w3.org/TR/2008/REC-xml-20081126/" target="_blank" rel="noopener">XML 1.0 fifth
edition</a> and <a href="http://www.w3.org/TR/2009/REC-xml-names-20091208/" target="_blank" rel="noopener">XML Namespaces 1.0
third edition</a>.</p>
<p>Consequently, saxes does not support HTML, or pseudo-XML, or bad XML.</p>
</li>
<li>
<p>Saxes is much much faster than sax, mostly because of a substantial redesign
of the internal parsing logic. The speed improvement is not merely due to
removing features that were supported by sax. That helped a bit, but saxes
adds some expensive checks in its aim for conformance with the XML
specification. Redesigning the parsing logic is what accounts for most of the
performance improvement.</p>
</li>
<li>
<p>Saxes does not aim to support antiquated platforms. We will not pollute the
source or the default build with support for antiquated platforms. If you want
support for IE 11, you are welcome to produce a PR that adds a <em>new build</em>
transpiled to ES5.</p>
</li>
<li>
<p>Saxes handles errors differently from sax: it provides a default onerror
handler which throws. You can replace it with your own handler if you want. If
your handler does nothing, there is no <code>resume</code> method to call.</p>
</li>
<li>
<p>There&apos;s no <code>Stream</code> API. A revamped API may be introduced later. (It is still
a &quot;streaming parser&quot; in the general sense that you write a character stream to
it.)</p>
</li>
<li>
<p>Saxes does not have facilities for limiting the size the data chunks passed to
event handlers. See the FAQ entry for more details.</p>
</li>
</ul>
<h2>Limitations</h2>
<p>This is a non-validating parser so it only verifies whether the document is
well-formed. We do aim to raise errors for all malformed constructs encountered.</p>
<p>However, this parser does not parse the contents of DTDs. So malformedness
errors caused by errors in DTDs cannot be reported.</p>
<p>Also, the parser continues to parse even upon encountering errors, and does its
best to continue reporting errors. You should heed all errors
reported.</p>
<p><strong>HOWEVER, ONCE AN ERROR HAS BEEN ENCOUNTERED YOU CANNOT RELY ON THE DATA
PROVIDED THROUGH THE OTHER EVENT HANDLERS.</strong></p>
<p>After an error, saxes tries to make sense of your document, but it may interpret
it incorrectly. For instance <code>&lt;foo a=bc=&quot;d&quot;/&gt;</code> is invalid XML. Did you mean to
have <code>&lt;foo a=&quot;bc=d&quot;/&gt;</code> or <code>&lt;foo a=&quot;b&quot; c=&quot;d&quot;/&gt;</code> or some other variation?
Saxes takes an honest stab at figuring out your mangled XML. That&apos;s as good as
it gets.</p>
<h2>Regarding <code>&lt;!DOCTYPE</code>s and <code>&lt;!ENTITY</code>s</h2>
<p>The parser will handle the basic XML entities in text nodes and attribute
values: <code>&amp;amp; &amp;lt; &amp;gt; &amp;apos; &amp;quot;</code>. It&apos;s possible to define additional
entities in XML by putting them in the DTD. This parser doesn&apos;t do anything with
that. If you want to listen to the <code>ondoctype</code> event, and then fetch the
doctypes, and read the entities and add them to <code>parser.ENTITIES</code>, then be my
guest.</p>
<h2>Documentation</h2>
<p>The source code contains JSDOC comments. Use them.</p>
<p><strong>PAY CLOSE ATTENTION TO WHAT IS PUBLIC AND WHAT IS PRIVATE.</strong></p>
<p>The elements of code that do not have JSDOC documentation, or have documentation
with the <code>@private</code> tag, are private.</p>
<p>If you use anything private, that&apos;s at your own peril.</p>
<p>If there&apos;s a mistake in the documentation, raise an issue. If you just assume,
you may assume incorrectly.</p>
<h2>Summary Usage Information</h2>
<h3>Example</h3>
<pre class="hljs"><code><span class="hljs-keyword">var</span> saxes = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./lib/saxes&quot;</span>),
  parser = <span class="hljs-keyword">new</span> saxes.SaxesParser();

parser.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
  <span class="hljs-comment">// an error happened.</span>
};
parser.ontext = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
  <span class="hljs-comment">// got some text.  t is the string of text.</span>
};
parser.onopentag = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
  <span class="hljs-comment">// opened a tag.  node has &quot;name&quot; and &quot;attributes&quot;</span>
};
parser.onend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// parser stream is done, and ready to have more stuff written to it.</span>
};

parser.write(<span class="hljs-string">&apos;&lt;xml&gt;Hello, &lt;who name=&quot;world&quot;&gt;world&lt;/who&gt;!&lt;/xml&gt;&apos;</span>).close();
</code></pre>
<h3>Constructor Arguments</h3>
<p>Pass the following arguments to the parser function. All are optional.</p>
<p><code>opt</code> - Object bag of settings regarding string formatting.</p>
<p>Settings supported:</p>
<ul>
<li>
<p><code>xmlns</code> - Boolean. If <code>true</code>, then namespaces are supported. Default
is <code>false</code>.</p>
</li>
<li>
<p><code>position</code> - Boolean. If <code>false</code>, then don&apos;t track line/col/position. Unset is
treated as <code>true</code>. Default is unset.</p>
</li>
<li>
<p><code>fileName</code> - String. Set a file name for error reporting. This is useful only
when tracking positions. You may leave it unset, in which case the file name
in error messages will be <code>undefined</code>.</p>
</li>
<li>
<p><code>fragment</code> - Boolean. If <code>true</code>, parse the XML as an XML fragment. Default is
<code>false</code>.</p>
</li>
<li>
<p><code>additionalNamespaces</code> - A plain object whose key, value pairs define
namespaces known before parsing the XML file. It is not legal to pass
bindings for the namespaces <code>&quot;xml&quot;</code> or <code>&quot;xmlns&quot;</code>.</p>
</li>
</ul>
<h3>Methods</h3>
<p><code>write</code> - Write bytes onto the stream. You don&apos;t have to do this all at
once. You can keep writing as much as you want.</p>
<p><code>close</code> - Close the stream. Once closed, no more data may be written until it is
done processing the buffer, which is signaled by the <code>end</code> event.</p>
<h3>Properties</h3>
<p>The parser has the following properties:</p>
<p><code>line</code>, <code>column</code>, <code>position</code> - Indications of the position in the XML document
where the parser currently is looking.</p>
<p><code>closed</code> - Boolean indicating whether or not the parser can be written to.  If
it&apos;s <code>true</code>, then wait for the <code>ready</code> event to write again.</p>
<p><code>opt</code> - Any options passed into the constructor.</p>
<p><code>xmlDecl</code> - The XML declaration for this document. It contains the fields
<code>version</code>, <code>encoding</code> and <code>standalone</code>. They are all <code>undefined</code> before
encountering the XML declaration. If they are undefined after the XML
declaration, the corresponding value was not set by the declaration. There is no
event associated with the XML declaration. In a well-formed document, the XML
declaration may be preceded only by an optional BOM. So by the time any event
generated by the parser happens, the declaration has been processed if present
at all. Otherwise, you have a malformed document, and as stated above, you
cannot rely on the parser data!</p>
<h3>Events</h3>
<p>To listen to an event, override <code>on&lt;eventname&gt;</code>. The list of supported events
are also in the exported <code>EVENTS</code> array.</p>
<p>See the JSDOC comments in the source code for a description of each supported
event.</p>
<h3>Parsing XML Fragments</h3>
<p>The XML specification does not define any method by which to parse XML
fragments. However, there are usage scenarios in which it is desirable to parse
fragments. In order to allow this, saxes provides three initialization options.</p>
<p>If you pass the option <code>fragment: true</code> to the parser constructor, the parser
will expect an XML fragment. It essentially starts with a parsing state
equivalent to the one it would be in if <code>parser.write(&quot;&lt;foo&quot;&gt;)</code> had been called
right after initialization. In other words, it expects content which is
acceptable inside an element. This also turns off well-formedness checks that
are inappropriate when parsing a fragment.</p>
<p>The option <code>additionalNamespaces</code> allows you to define additional prefix-to-URI
bindings known before parsing starts. You would use this over <code>resolvePrefix</code> if
you have at the ready a series of namespaces bindings to use.</p>
<p>The option <code>resolvePrefix</code> allows you to pass a function which saxes will use if
it is unable to resolve a namespace prefix by itself. You would use this over
<code>additionalNamespaces</code> in a context where getting a complete list of defined
namespaces is onerous.</p>
<p>Note that you can use <code>additionalNamespaces</code> and <code>resolvePrefix</code> together if you
want. <code>additionalNamespaces</code> applies before <code>resolvePrefix</code>.</p>
<h2>FAQ</h2>
<p>Q. Why has saxes dropped support for limiting the size of data chunks passed to
event handlers?</p>
<p>A. With sax you could set <code>MAX_BUFFER_LENGTH</code> to cause the parser to limit the
size of data chunks passed to event handlers. So if you ran into a span of text
above the limit, multiple <code>text</code> events with smaller data chunks were fired
instead of a single event with a large chunk.</p>
<p>However, that functionality had some problematic characteristics. It had an
arbitrary default value. It was library-wide so all parsers created from a
single instance of the <code>sax</code> library shared it. This could potentially cause
conflicts among libraries running in the same VM but using sax for different
purposes.</p>
<p>These issues could have been easily fixed, but there were larger issues. The
buffer limit arbitrarily applied to some events but not others. It would split
<code>text</code>, <code>cdata</code> and <code>script</code> events. However, if a <code>comment</code>,
<code>doctype</code>, <code>attribute</code> or <code>processing instruction</code> were more than the
limit, the parser would generate an error and you were left picking up the
pieces.</p>
<p>It was not intuitive to use. You&apos;d think setting the limit to 1K would prevent
chunks bigger than 1K to be passed to event handlers. But that was not the
case. A comment in the source code told you that you might go over the limit if
you passed large chunks to <code>write</code>. So if you want a 1K limit, don&apos;t pass 64K
chunks to <code>write</code>. Fair enough. You know what limit you want so you can
control the size of the data you pass to <code>write</code>. So you limit the chunks to
<code>write</code> to 1K at a time. Even if you do this, your event handlers may get data
chunks that are 2K in size. Suppose on the previous <code>write</code> the parser has
just finished processing an open tag, so it is ready for text. Your <code>write</code>
passes 1K of text. You are not above the limit yet, so no event is generated
yet. The next <code>write</code> passes another 1K of text. It so happens that sax checks
buffer limits only once per <code>write</code>, after the chunk of data has been
processed. Now you&apos;ve hit the limit and you get a <code>text</code> event with 2K of
data. So even if you limit your <code>write</code> calls to the buffer limit you&apos;ve set,
you may still get events with chunks at twice the buffer size limit you&apos;ve
specified.</p>
<p>We may consider reinstating an equivalent functionality, provided that it
addresses the issues above and does not cause a huge performance drop for
use-case scenarios that don&apos;t need it.</p>
</body></html></div>
        </main>
      </div>
    </div>
<footer class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-2 mb-md-0 mb-4">
        <span class="pr-md-5 pr-0 py-3">
          <a href="https://runtimeverification.com" target="_blank">
            <picture>
              <source
                srcset="../../../assets/img/rv-logo-dark.png"
                media="(prefers-color-scheme: dark)"
              />
              <img
                class="pr-3 footer-logo"
                src="../../../assets/img/rv-logo.png"
                alt="Runtime Verification Inc logo"
              />
            </picture>
          </a>
        </span>
      </div>
      <div class="col-md-6 mb-md-0 mb-4"></div>
      <div class="col-md-4 text-md-right">
        <p class="copyright">
          &copy; 2020 Runtime Verification Inc. All right reserved.
        </p>
      </div>
    </div>
  </div>
</footer>

<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-163311512-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", "UA-163311512-1");
</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../assets/js/index.js"></script>
  </body>
</html>
